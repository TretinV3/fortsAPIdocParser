{
   "DoorCountAI": {
      "documentation": [
         "int DoorCountAI(int id)",
         "local result = DoorCountAI(id)"
      ],
      "description": "Excludes repairing doors"
   },
   "EnableAI": {
      "documentation": [
         "void EnableAI(int teamId, const char* fort, float difficulty, int fortIdPos = -1)",
         "EnableAI(1, \"fort-t1-Vanilla-1\", 0.5, -1)"
      ],
      "description": "Enable the Artificial Intelligence for a particular team, to use a specific fort script, difficulty and fort position\nCall this in your Load event\nteamId: the team to assign the fort script to \nfort: the filename of the script, relative to the map folder with no extension \ndifficulty: how hard the AI should be [0-1] \nfortIfPos: integer position of the fort (-1 will auto select) \nSee also: Load"
   },
   "SetAIClearanceMinimum": {
      "documentation": [
         "void SetAIClearanceMinimum(float aiClearanceMinimum)",
         "SetAIClearanceMinimum(aiClearanceMinimum)"
      ],
      "description": "Set the minimum extra fire clearance for AI\naiClearanceMinimum: The minimum fire clearance for the AI if FIREFLAG_EXTRACLEARANCE is used "
   },
   "AdjustStreamVolume": {
      "documentation": [
         "void AdjustStreamVolume(int seriesId, float duration, float volume)",
         "AdjustStreamVolume(seriesId, duration, volume)"
      ],
      "description": "Changes the volume of the stream over duration\nSee also: StartStream, FadeStream"
   },
   "ContinueStreamOnPauseMenu": {
      "documentation": [
         "void ContinueStreamOnPauseMenu(int seriesId)",
         "ContinueStreamOnPauseMenu(seriesId)"
      ],
      "description": "Stream resumes when pause menu is shown\nSee also: StartStream"
   },
   "DisableMusic": {
      "documentation": [
         "void DisableMusic()",
         "DisableMusic()"
      ],
      "description": "Prevents dynamic music operating"
   },
   "FadeStream": {
      "documentation": [
         "void FadeStream(int seriesId, float duration)",
         "FadeStream(seriesId, duration)"
      ],
      "description": "Reduces the volume of a stream over duration\nSee also: StartStream, AdjustStreamVolume, DisableMusic"
   },
   "PauseStream": {
      "documentation": [
         "void PauseStream(int seriesId, bool pause, float fadePeriod)",
         "PauseStream(seriesId, pause, fadePeriod)"
      ],
      "description": "Pauses a stream started by StartStream\nSee also: StartStream, PauseStreamOnAdvance"
   },
   "PauseStreamOnAdvance": {
      "documentation": [
         "void PauseStreamOnAdvance(int seriesId, bool pause)",
         "PauseStreamOnAdvance(seriesId, pause)"
      ],
      "description": "When pause is true the stream pauses itself when it ends\nSee also: StartStream, PauseStream, ContinueStreamOnPauseMenu"
   },
   "SetAudioParameter": {
      "documentation": [
         "void SetAudioParameter(unsigned int id, const char* name, float value)",
         "SetAudioParameter(id, name, value)"
      ],
      "description": "Sets a audio parameter on a specific effect instance\nSee also: SetGlobalAudioParameter, SpawnEffect"
   },
   "SetGlobalAudioParameter": {
      "documentation": [
         "void SetGlobalAudioParameter(const char* name, float value)",
         "SetGlobalAudioParameter(name, value)"
      ],
      "description": "Sets a global audio parameter\nSee also: SetAudioParameter"
   },
   "StartMusic": {
      "documentation": [
         "int StartMusic(const char* filename, bool loop, bool randomise)",
         "local result = StartMusic(filename, loop, randomise)"
      ],
      "description": "Plays an individual music file or fmod event\nSee also: StartStream"
   },
   "StartStream": {
      "documentation": [
         "int StartStream(const char* filename, float volume)",
         "local seriesId = StartStream(filename, volume)"
      ],
      "description": "Starts streaming an audio file, fmod event, or list of at the given volume\nCalls OnStreamComplete when the stream ends\nIntended for audio dialog clips\nfilename: can be a file path, fmod event name, or a constants table of these \nvolume: the volume to play the stream at \nreturns: the id which can be passed to PauseStream, FadeStream and other stream functions\nSee also: PauseStream, PauseStreamOnAdvance, FadeStream"
   },
   "StopAllStreams": {
      "documentation": [
         "void StopAllStreams()",
         "StopAllStreams()"
      ],
      "description": "Ends all streams started by the current script\nSee also: StartStream, DisableMusic"
   },
   "StopStream": {
      "documentation": [
         "void StopStream(int seriesId)",
         "StopStream(seriesId)"
      ],
      "description": "Stops a stream started by StartStream or StartMusic\nSee also: PauseStream, FadeStream, StartStream"
   },
   "ActivateCommander": {
      "documentation": [
         "void ActivateCommander(int teamId)",
         "ActivateCommander(teamId)"
      ],
      "description": "Activate the commander for the given side"
   },
   "GetTeamCommanderPoints": {
      "documentation": [
         "float GetTeamCommanderPoints(int teamId)",
         "local progress = GetTeamCommanderPoints(teamId)"
      ],
      "description": "Query the commander charge progress of a side\nreturns: a number in the range [0-1]"
   },
   "IsCommanderActive": {
      "documentation": [
         "bool IsCommanderActive(int teamId)",
         "local result = IsCommanderActive(teamId)"
      ],
      "description": "Query whether the commander is active for the given side"
   },
   "GetConstant": {
      "documentation": [
         "float GetConstant(const char* name)",
         "local result = GetConstant(\"Physics.Gravity\")"
      ],
      "description": "Query the value of a constant of type float"
   },
   "GetConstantString": {
      "documentation": [
         "const char* GetConstantString(const char* name)",
         "local result = GetConstantString(\"Game.DefaultMap\")"
      ],
      "description": "Query the value of a constant of type string"
   },
   "GetRule": {
      "documentation": [
         "float GetRule(int teamId, const char* name)",
         "local result = GetRule(1, \"RepairFieldSpeedFactor\")"
      ],
      "description": "Query the value of a rule by teamId and name, of type float"
   },
   "Log": {
      "documentation": [
         "void Log(const char* text)",
         "Log(L\"Only ANSI characters accepted here\")"
      ],
      "description": "Write a message to the console and log.txt\nIf text begins with \"Error\" the line will be highlighted in red on the console\nTo find log.txt, go to Steam and right click on Forts -> Properties -> Local files -> browse local files, then navigate to Forts/users/(steamid)/"
   },
   "LogToFile": {
      "documentation": [
         "void LogToFile(const char* text)",
         "LogToFile(L\"Only ANSI characters accepted here\")"
      ],
      "description": "Write a message to log.txt\n(same as Log but doesn't display the message in the console)"
   },
   "LogToFileW": {
      "documentation": [
         "void LogToFileW(const wchar_t* text)",
         "LogToFileW(L\"Non-ANSI characters accepted here\")"
      ],
      "description": "Write a wide character message to log.txt\n(same as Log but doesn't display the message in the console)"
   },
   "LogW": {
      "documentation": [
         "void LogW(const wchar_t* text)",
         "LogW(L\"Non-ANSI characters accepted here\")"
      ],
      "description": "Write a wide character message to the console and log.txt\nIf text begins with \"Error\" the line will be highlighted in red on the console\nTo find log.txt, go to Steam and right click on Forts -> Properties -> Local files -> browse local files, then navigate to Forts/users/(steamid)/"
   },
   "Notice": {
      "documentation": [
         "void Notice(const char* text)",
         "Notice(\"Hello, World!\")"
      ],
      "description": "Drops a notification in the console without string translation"
   },
   "SpawnCircle": {
      "documentation": [
         "unsigned int SpawnCircle(const Vector3D& pos, float radius, const Colour& colour, float duration)",
         "local id = SpawnCircle(pos, radius, colour, duration)"
      ],
      "description": "Spawns a temporary circle effect\nIntended for debugging only\nreturns: the effect id which can be passed to:\nSee also: CancelEffect, DisableEffect, SetEffectPosition, SetEffectDirection, and, AddToEffectLifeSpan\nSee also: SpawnLine"
   },
   "SpawnLine": {
      "documentation": [
         "unsigned int SpawnLine(const Vector3D& posA, const Vector3D& posB, const Colour& colour, float duration)",
         "local id = SpawnLine(posA, posB, colour, duration)"
      ],
      "description": "Spawns a temporary line effect\nIntended for debugging only\nreturns: the effect id which can be passed to:\nSee also: CancelEffect, DisableEffect, SetEffectPosition, SetEffectDirection, and, AddToEffectLifeSpan\nSee also: SpawnCircle"
   },
   "towstring": {
      "documentation": [
         "const wchar_t* towstring(const char* text)",
         "local result = towstring(text)"
      ],
      "description": "Convert an ANSI string to a wide character string (UTF-16LE)"
   },
   "AimWeapon": {
      "documentation": [
         "bool AimWeapon(int id, const Vector3D& target)",
         "local result = AimWeapon(id, target)"
      ],
      "description": "Returns true if able to hit the target\nUse GetAimWeaponAngle and GetAimWeaponSpeed to query aiming solution"
   },
   "ApplyDamageToDevice": {
      "documentation": [
         "float ApplyDamageToDevice(int deviceId, float damage)",
         "local result = ApplyDamageToDevice(deviceId, damage)"
      ],
      "description": "Damages the given device, returns the new absolute health in hitpoints"
   },
   "ClearWeaponPaintTarget": {
      "documentation": [
         "void ClearWeaponPaintTarget(int id)",
         "ClearWeaponPaintTarget(id)"
      ],
      "description": "Cancel the target of a missile type weapon\nSee also: SetWeaponPaintTarget"
   },
   "CreateDevice": {
      "documentation": [
         "int CreateDevice(int deviceTeamId, const char* saveName, int nodeIdA, int nodeIdB, float t)",
         "local result = CreateDevice(deviceTeamId, saveName, nodeIdA, nodeIdB, t)"
      ],
      "description": "Spawns a new device on the specified platform\nSets a value for GetBlockingDevice when return value is CD_OCCUPIED\ndeviceTeamId: the team the device should belong to (must match platform owner) \nsaveName: the type of the device to create \nnodeIdA: the first node id of the platform \nnodeIdB: the second node id of the platform \nt: the position on the platform to make the device [0-1] \nSee also: CreateGroundDevice, DestroyDevice, DestroyDeviceById"
   },
   "CreateDeviceWithFlags": {
      "documentation": [
         "int CreateDeviceWithFlags(int deviceTeamId, const char* saveName, int nodeIdA, int nodeIdB, float t, int flags, int movingDeviceId)",
         "local result = CreateDeviceWithFlags(deviceTeamId, saveName, nodeIdA, nodeIdB, t, flags, movingDeviceId)"
      ],
      "description": "Spawns a new device on the specified platform using specified create device flags\nSets a value for GetBlockingDevice when return value is CD_OCCUPIED or CD_OCCUPIED\ndeviceTeamId: the team the device should belong to (must match platform owner) \nsaveName: the type of the device to create \nnodeIdA: the first node id of the platform \nnodeIdB: the second node id of the platform \nt: the position on the platform to make the device [0-1] \nflags: the CREATEDEVICEFLAG to apply, e.g. CREATEDEVICEFLAG_IGNORERECESSIONCOST \nSee also: CreateDevice, CreateGroundDevice, DestroyDevice, DestroyDeviceById, GetBlockingDevice"
   },
   "CreateGroundDevice": {
      "documentation": [
         "int CreateGroundDevice(int deviceTeamId, const char* saveName, const Vector3D& position, float angle)",
         "local result = CreateGroundDevice(deviceTeamId, saveName, position, angle)"
      ],
      "description": "Spawns a device on the ground\nThe position must be on suitable terrain within range of a fort\nSets a value for GetBlockingDevice when return value is CS_OBSTRUCTION or CD_OCCUPIED\ndeviceTeamId: the team the device should belong to (must match the ground owner) \nsaveName: the type of the device to create \nposition: the location to place the device (must be on the ground) \nangle: in degrees with 90 pointing up \nSee also: CreateDevice, DestroyDevice, DestroyDeviceById, GetBlockingDevice"
   },
   "DestroyDevice": {
      "documentation": [
         "int DestroyDevice(int teamId, int nodeIdA, int nodeIdB)",
         "local result = DestroyDevice(teamId, nodeIdA, nodeIdB)"
      ],
      "description": "Starts the salvage process for the device on the given platform"
   },
   "DestroyDeviceAtPos": {
      "documentation": [
         "int DestroyDeviceAtPos(int teamId, const Vector3D& position)",
         "local result = DestroyDeviceAtPos(teamId, position)"
      ],
      "description": "Starts the salvage process for the device at the given position"
   },
   "DestroyDeviceById": {
      "documentation": [
         "int DestroyDeviceById(int deviceId)",
         "local result = DestroyDeviceById(deviceId)"
      ],
      "description": "Starts the salvage process for the given device"
   },
   "DeviceCanBeDestroyedById": {
      "documentation": [
         "bool DeviceCanBeDestroyedById(int deviceId)",
         "local result = DeviceCanBeDestroyedById(deviceId)"
      ],
      "description": "Queries whether the specified device can be reclaimed\nThe reactor can't be, as an example"
   },
   "DeviceDisabled": {
      "documentation": [
         "bool DeviceDisabled(int deviceId)",
         "local result = DeviceDisabled(deviceId)"
      ],
      "description": "Returns true if device has been disabled by EMP"
   },
   "DeviceExists": {
      "documentation": [
         "bool DeviceExists(int deviceId)",
         "local result = DeviceExists(deviceId)"
      ],
      "description": "Returns true if the given deviceId is valid"
   },
   "DeviceExpired": {
      "documentation": [
         "bool DeviceExpired(int deviceId)",
         "local result = DeviceExpired(deviceId)"
      ],
      "description": "For weapons that expire after a set number of bursts, this will\nreturn true if the final burst been spawned, but the weapon has not yet been destroyed"
   },
   "dlc2_CreateFloatingDevice": {
      "documentation": [
         "int dlc2_CreateFloatingDevice(int deviceTeamId, const char* saveName, const Vector3D& position, float angle)",
         "local result = dlc2_CreateFloatingDevice(deviceTeamId, saveName, position, angle)"
      ],
      "description": "Spawns a disembodied device anywhere (except inside solid ground)\nThe device's dlc2_BuildAnywhere must be set to true in device_list.lua\nThe position must be on suitable terrain within range of a fort\nSets a value for GetBlockingDevice when return value is CS_OBSTRUCTION or CD_OCCUPIED\nRequires the High Seas DLC (dlc2)\ndeviceTeamId: the team the device should belong to (must match the ground owner) \nsaveName: the type of the device to create \nposition: the location to place the device (must be on the ground) \nangle: in degrees with 90 pointing up \nSee also: CreateDevice, DestroyDevice, DestroyDeviceById, GetBlockingDevice"
   },
   "dlc2_SetDevicePosition": {
      "documentation": [
         "void dlc2_SetDevicePosition(int deviceId, const Vector3D& pos)",
         "dlc2_SetDevicePosition(deviceId, pos)"
      ],
      "description": "Moves a ground or floating device to a position\nRequires the High Seas DLC (dlc2)"
   },
   "EMPDevice": {
      "documentation": [
         "void EMPDevice(int deviceId, float duration)",
         "EMPDevice(deviceId, duration)"
      ],
      "description": "Disables the device as if hit by an EMP\ndeviceId: the id of the device to disable \nduration: how long the device is disabled for in seconds "
   },
   "EnableDevice": {
      "documentation": [
         "void EnableDevice(const char* saveName, bool enable, int sideId)",
         "EnableDevice(saveName, enable, sideId)"
      ],
      "description": "Enables or disables a device for a side\nsaveName: can be \"*\" to apply to all devices \nSee also: EnableWeapon"
   },
   "EnableDeviceUpgrade": {
      "documentation": [
         "void EnableDeviceUpgrade(const char* deviceSaveName, const char* upgradeSaveName, int sideId, bool enable)",
         "EnableDeviceUpgrade(deviceSaveName, upgradeSaveName, sideId, enable)"
      ],
      "description": "Enable or disable the upgrade of one device to another for a side\nSee also: EnableWeaponUpgrade"
   },
   "EnableWeapon": {
      "documentation": [
         "void EnableWeapon(const char* saveName, bool enable, int sideId)",
         "EnableWeapon(saveName, enable, sideId)"
      ],
      "description": "Enables or disables a weapon for a side\nsaveName: can be \"*\" to apply to all weapons \nSee also: EnableDevice"
   },
   "EnableWeaponUpgrade": {
      "documentation": [
         "void EnableWeaponUpgrade(const char* deviceSaveName, const char* upgradeSaveName, int sideId, bool enable)",
         "EnableWeaponUpgrade(deviceSaveName, upgradeSaveName, sideId, enable)"
      ],
      "description": "Enable or disable the upgrade of one weapon to another for a side\nSee also: EnableDeviceUpgrade"
   },
   "FindClosestDeviceOnStructure": {
      "documentation": [
         "int FindClosestDeviceOnStructure(const Vector3D& pos, int structureId, const char* saveName)",
         "local deviceId = FindClosestDeviceOnStructure(pos, structureId, saveName)"
      ],
      "description": "Searches for the nearest device on the same structure with the specified saveName\npos: The position to search from \nstructureId: The structure to search on (0 for all structures) \nsaveName: The device saveName to look for (empty string for all devices) \nreturns: The id of the found device (0 if none found)"
   },
   "FindDeviceInstance": {
      "documentation": [
         "int FindDeviceInstance(const char* saveName, int teamId, bool acceptIncomplete, int index)",
         "local id = FindDeviceInstance(saveName, teamId, acceptIncomplete, index)"
      ],
      "description": "Returns the id of the Nth instance of a device type\nindex: the list position to return, starting at 0 \nsaveName: the device or weapon type to find \nteamId: the team to search \nacceptIncomplete: if true then devices under construction or being scrapped are returned \nreturns: -1 if there is no instance with the given index"
   },
   "FindVisibleAngles": {
      "documentation": [
         "int FindVisibleAngles(int weaponId)",
         "local count = FindVisibleAngles(weaponId)"
      ],
      "description": "Starts a search for the visible angles from the perspective of a weapon\nCan be narrowed using other functions (below).\nweaponId: The weapon to search from \nreturns: The number of angle brackets found\nSee also: NarrowVisibleAnglesBySide, NarrowVisibleAnglesBySegment, GetVisibleAngleBracket"
   },
   "FireWeapon": {
      "documentation": [
         "int FireWeapon(int id, const Vector3D& target, float stdDev, int flags)",
         "local result = FireWeapon(id, target, stdDev, flags)"
      ],
      "description": "Attempts to fire the given weapon at target with some error\nstdDev: standard deviation (normal distribution) for error on calculated fire angle (in degrees)\nuse GetRayHitLinkNodeIdA and GetRayHitLinkNodeIdB to query blocking structure\nflags: one of the FIREFLAG_* values from forts.lua (typically use FIREFLAG_NORMAL) \nreturns: one of the FIRE_* values from forts.lua (e.g. FIRE_SUCCESS)\nSee also: FireWeaponWithPower"
   },
   "FireWeaponWithPower": {
      "documentation": [
         "int FireWeaponWithPower(int id, const Vector3D& target, float stdDev, float stdDevTestOverride, int flags, float power)",
         "local result = FireWeaponWithPower(id, target, stdDev, stdDevTestOverride, flags, power)"
      ],
      "description": "Attempts to fire the given weapon at target with some error and level of power\nstdDev: standard deviation (normal distribution) for error on calculated fire angle (in degrees)\nstdDevTestOverride: standard deviation (normal distribution) for maximum friendly structure collision tests, < 0 means ignore and use stdDev value for collision tests\nUse GetRayHitLinkNodeIdA and GetRayHitLinkNodeIdB to query blocking structure\nflags: one of the FIREFLAG_* values from forts.lua (typically use FIREFLAG_NORMAL) \npower: affects the speed or spread of the shot as if cursor is closer or further from the weapon in the aiming arc [0-1] \nreturns: one of the FIRE_* values from forts.lua (e.g. FIRE_SUCCESS)\nSee also: FireWeapon, OnWeaponFired"
   },
   "GetAimWeaponAngle": {
      "documentation": [
         "float GetAimWeaponAngle()",
         "local result = GetAimWeaponAngle()"
      ],
      "description": "Returns the angle needed to hit the target calculated in AimWeapon"
   },
   "GetAimWeaponSpeed": {
      "documentation": [
         "float GetAimWeaponSpeed()",
         "local result = GetAimWeaponSpeed()"
      ],
      "description": "Returns the speed needed to hit the target calculated in AimWeapon"
   },
   "GetBlockingDevice": {
      "documentation": [
         "int GetBlockingDevice()",
         "local result = GetBlockingDevice()"
      ],
      "description": "Returns the deviceId of the device blocking CreateGroundDevice() or CreateDevice()"
   },
   "GetDeviceAngle": {
      "documentation": [
         "float GetDeviceAngle(int deviceId)",
         "local result = GetDeviceAngle(deviceId)"
      ],
      "description": "Queries the orientation of a device"
   },
   "GetDeviceCanClaimStructures": {
      "documentation": [
         "bool GetDeviceCanClaimStructures(int deviceId)",
         "local result = GetDeviceCanClaimStructures(deviceId)"
      ],
      "description": "Queries whether a device can claim structures"
   },
   "GetDeviceCentrePosition": {
      "documentation": [
         "Vector3D GetDeviceCentrePosition(int deviceId)",
         "local result = GetDeviceCentrePosition(deviceId)"
      ],
      "description": "Queries the center of a device's bounding box\nIncludes device on platforms or on the ground\nSee also: GetDevicePosition"
   },
   "GetDeviceComponentPosition": {
      "documentation": [
         "Vector3D GetDeviceComponentPosition(int deviceId, const char* component)",
         "local result = GetDeviceComponentPosition(deviceId, component)"
      ],
      "description": "Queries the position of a component of the given device\nSee also: GetDevicePosition, GetDeviceCentrePosition"
   },
   "GetDeviceCost": {
      "documentation": [
         "::Value GetDeviceCost(const char* saveName)",
         "local result = GetDeviceCost(saveName)"
      ],
      "description": "Query the cost of building the given device"
   },
   "GetDeviceCount": {
      "documentation": [
         "int GetDeviceCount(int teamId)",
         "local count = GetDeviceCount(teamId)"
      ],
      "description": "Query the number of devices on a team\nIncludes weapons (which are specialised devices)\nreturns: the number of devices on teamId\nSee also: GetDeviceId"
   },
   "GetDeviceCountSide": {
      "documentation": [
         "int GetDeviceCountSide(int sideId)",
         "local count = GetDeviceCountSide(sideId)"
      ],
      "description": "Device count includes weapons (which are specialised devices)\nreturns: the number of devices on sideId\nSee also: GetDeviceIdSide"
   },
   "GetDeviceEfficiency": {
      "documentation": [
         "float GetDeviceEfficiency(int deviceId)",
         "local result = GetDeviceEfficiency(deviceId)"
      ],
      "description": "Queries the performance of a device (e.g. turbine)"
   },
   "GetDeviceEnabled": {
      "documentation": [
         "bool GetDeviceEnabled(const char* saveName, int sideId)",
         "local result = GetDeviceEnabled(saveName, sideId)"
      ],
      "description": "Query whether a device or weapon on a side is enabled for building"
   },
   "GetDeviceForward": {
      "documentation": [
         "Vector3D GetDeviceForward(int deviceId)",
         "local result = GetDeviceForward(deviceId)"
      ],
      "description": "Queries the forward vector of the given device"
   },
   "GetDeviceHealth": {
      "documentation": [
         "float GetDeviceHealth(int deviceId)",
         "local result = GetDeviceHealth(deviceId)"
      ],
      "description": "Returns the relative health of the device in the range [0-1]"
   },
   "GetDeviceHitpoints": {
      "documentation": [
         "float GetDeviceHitpoints(int deviceId)",
         "local result = GetDeviceHitpoints(deviceId)"
      ],
      "description": "Returns the absolute health of the device in hitpoints"
   },
   "GetDeviceId": {
      "documentation": [
         "int GetDeviceId(int teamId, int index)",
         "local id = GetDeviceId(teamId, index)"
      ],
      "description": "Query the id for a particular device at index on a team\nUse GetDeviceCount to get suitable values for index (zero based)\nreturns: the id of the device at index\nSee also: GetDeviceCount"
   },
   "GetDeviceIdAtPosition": {
      "documentation": [
         "int GetDeviceIdAtPosition(const Vector3D& pos)",
         "local deviceId = GetDeviceIdAtPosition(pos)"
      ],
      "description": "Queries the device id at the given position\nreturns: -1 if not found"
   },
   "GetDeviceIdOnPlatform": {
      "documentation": [
         "int GetDeviceIdOnPlatform(int nodeIdA, int nodeIdB)",
         "local deviceId = GetDeviceIdOnPlatform(nodeIdA, nodeIdB)"
      ],
      "description": "Queries the device id on a specific platform\nDevice is also returned if on reverse direction\nreturns: -1 if not found\nSee also: GetDevicePlatformA, GetDevicePlatformB"
   },
   "GetDeviceIdSide": {
      "documentation": [
         "int GetDeviceIdSide(int sideId, int index)",
         "local id = GetDeviceIdSide(sideId, index)"
      ],
      "description": "Query the id for a particular device at index on a side (1 or 2)\nUse GetDeviceCountSide to get suitable values for index (zero based)\nreturns: the id of the device at index\nSee also: GetDeviceCountSide"
   },
   "GetDeviceLinkPosition": {
      "documentation": [
         "float GetDeviceLinkPosition(int deviceId)",
         "local t = GetDeviceLinkPosition(deviceId)"
      ],
      "description": "Queries how far along the platform the device is placed\nreturns: position in the range [0-1]"
   },
   "GetDeviceMovingId": {
      "documentation": [
         "int GetDeviceMovingId(int deviceId)",
         "local result = GetDeviceMovingId(deviceId)"
      ],
      "description": "Queries the corresponding linked device id of a device being moved"
   },
   "GetDevicePlatformA": {
      "documentation": [
         "int GetDevicePlatformA(int deviceId)",
         "local nodeId = GetDevicePlatformA(deviceId)"
      ],
      "description": "Queries the first platform node of the given device\nreturns: the node id. 0 if not found.\nSee also: GetDevicePlatformB"
   },
   "GetDevicePlatformB": {
      "documentation": [
         "int GetDevicePlatformB(int deviceId)",
         "local nodeId = GetDevicePlatformB(deviceId)"
      ],
      "description": "Queries the second platform node of the given device\nreturns: the node id. 0 if not found.\nSee also: GetDevicePlatformA"
   },
   "GetDevicePosition": {
      "documentation": [
         "Vector3D GetDevicePosition(int deviceId)",
         "local result = GetDevicePosition(deviceId)"
      ],
      "description": "Queries the world position of a device\nIncludes device on platforms or on the ground\nSee also: GetDeviceCentrePosition"
   },
   "GetDeviceProductionRate": {
      "documentation": [
         "::Value GetDeviceProductionRate(int teamId, const char* saveName)",
         "local result = GetDeviceProductionRate(teamId, saveName)"
      ],
      "description": "Query the rate of metal and energy production in units per second"
   },
   "GetDeviceStructureId": {
      "documentation": [
         "int GetDeviceStructureId(int deviceId)",
         "local structureId = GetDeviceStructureId(deviceId)"
      ],
      "description": "Query the structure id that a device is attached to\nreturns: the structure id, 0 if none."
   },
   "GetDeviceTeamId": {
      "documentation": [
         "int GetDeviceTeamId(int deviceId)",
         "local result = GetDeviceTeamId(deviceId)"
      ],
      "description": "Query the side of a device\nThis should really be called GetDeviceSideId\nE.g. 1 or 2\nSee also: GetDeviceTeamIdActual"
   },
   "GetDeviceTeamIdActual": {
      "documentation": [
         "int GetDeviceTeamIdActual(int deviceId)",
         "local result = GetDeviceTeamIdActual(deviceId)"
      ],
      "description": "Query the team of a device\nIn team death match players can have their side and fort encoded into a large teamId\nE.g. 101 means team 1 of side 1, 102 means team 1 of side 2\nUse teamId%MAX_SIDES to get the sideId from a teamId\nSee also: GetDeviceTeamId"
   },
   "GetDeviceType": {
      "documentation": [
         "const char* GetDeviceType(int deviceId)",
         "local saveName = GetDeviceType(deviceId)"
      ],
      "description": "Queries the SaveName of the given device\nreturns: empty string if not found"
   },
   "GetDeviceTypeCount": {
      "documentation": [
         "int GetDeviceTypeCount(Owner sideId)",
         "local result = GetDeviceTypeCount(sideId)"
      ],
      "description": "Gets the number of device types for a side\nSee also: GetDeviceTypeSaveNameByIndex, GetDeviceTypeIndex"
   },
   "GetDeviceTypeIndex": {
      "documentation": [
         "int GetDeviceTypeIndex(const char* saveName)",
         "local index = GetDeviceTypeIndex(saveName)"
      ],
      "description": "Queries the device type index for a particular saveName\nreturns: -1 if saveName is invalid\nSee also: GetDeviceTypeCount"
   },
   "GetDeviceTypeSaveNameByIndex": {
      "documentation": [
         "const char* GetDeviceTypeSaveNameByIndex(int index, Owner sideId)",
         "local result = GetDeviceTypeSaveNameByIndex(index, sideId)"
      ],
      "description": "Gets a device type SaveName for a side\nSee also: GetDeviceTypeCount"
   },
   "GetDeviceTypeSplashDamageByIndex": {
      "documentation": [
         "const float GetDeviceTypeSplashDamageByIndex(int index, Owner sideId)",
         "local result = GetDeviceTypeSplashDamageByIndex(index, sideId)"
      ],
      "description": "Query the splash damage produced by the default ammo projectile this weapon spawns"
   },
   "GetFireAngle": {
      "documentation": [
         "float GetFireAngle(int id)",
         "local result = GetFireAngle(id)"
      ],
      "description": "Gets the current world angle of the weapon\nNot deterministic"
   },
   "GetFireSpeed": {
      "documentation": [
         "float GetFireSpeed(int id)",
         "local result = GetFireSpeed(id)"
      ],
      "description": "Gets the current fire speed of the weapon\nNot deterministic"
   },
   "GetFireVel": {
      "documentation": [
         "Vector3D GetFireVel(int id)",
         "local result = GetFireVel(id)"
      ],
      "description": "Get a vector representing the current direction and speed of fire for a weapon"
   },
   "GetFuseDelay": {
      "documentation": [
         "float GetFuseDelay(int id, float power)",
         "local result = GetFuseDelay(id, power)"
      ],
      "description": "Query the fuse delay for timed projectile weapons\nid: the device id of the weapon \npower: the speed or spread of the shot as if cursor is closer or further from the weapon in the aiming arc [0-1]. (use -1 for current weapon power) "
   },
   "GetLocalSelectedDeviceId": {
      "documentation": [
         "int GetLocalSelectedDeviceId()",
         "local id = GetLocalSelectedDeviceId()"
      ],
      "description": "Query the current device selection\nreturns: the selected device id, or -1 if none selected."
   },
   "GetMaxFireRadius": {
      "documentation": [
         "float GetMaxFireRadius(int id)",
         "local result = GetMaxFireRadius(id)"
      ],
      "description": "Query the outside radius of the aiming arc for a weapon\nid: the device id of the weapon "
   },
   "GetPlatformSupportsDevice": {
      "documentation": [
         "bool GetPlatformSupportsDevice(const Vector3D& pos1, const Vector3D& pos2, const char* deviceSaveName)",
         "local result = GetPlatformSupportsDevice(pos1, pos2, deviceSaveName)"
      ],
      "description": "Queries whether the a device type can be built on a given slope"
   },
   "GetVisibleAngleBracket": {
      "documentation": [
         "Vector3D GetVisibleAngleBracket(int index)",
         "local bracket = GetVisibleAngleBracket(index)"
      ],
      "description": "Query an angle bracket previously calculated by FindVisibleAngles\nindex: The index of the angle bracket \nreturns: The angle bracket: x is the first angle, y is the second angle\nSee also: FindVisibleAngles, GetVisibleAngleBracketCount"
   },
   "GetVisibleAngleBracketCount": {
      "documentation": [
         "int GetVisibleAngleBracketCount()",
         "local count = GetVisibleAngleBracketCount()"
      ],
      "description": "Query the number of angle brackets previously calculated by FindVisibleAngles\nreturns: The current number of angle brackets\nSee also: FindVisibleAngles, GetVisibleAngleBracket"
   },
   "GetWeaponAmmo": {
      "documentation": [
         "const char* GetWeaponAmmo(int deviceId)",
         "local result = GetWeaponAmmo(deviceId)"
      ],
      "description": "Queries the projectile SaveName that the weapon fires"
   },
   "GetWeaponAmmoWithProjectileCount": {
      "documentation": [
         "int GetWeaponAmmoWithProjectileCount(const char* saveName, int teamId)",
         "local result = GetWeaponAmmoWithProjectileCount(saveName, teamId)"
      ],
      "description": "Queries the number of ammo types a weapon has with a projectile type assigned"
   },
   "GetWeaponBarrelPosition": {
      "documentation": [
         "Vector3D GetWeaponBarrelPosition(int deviceId)",
         "local result = GetWeaponBarrelPosition(deviceId)"
      ],
      "description": "Queries the position of the \"Head\" sprite\nThis is approximately the pivot of the weapon, not really where projectiles are spawned\nSee also: GetDevicePosition, GetDeviceCentrePosition"
   },
   "GetWeaponBeamDamage": {
      "documentation": [
         "float GetWeaponBeamDamage(int weaponId, int teamId)",
         "local result = GetWeaponBeamDamage(weaponId, teamId)"
      ],
      "description": "Query the amount of beam damage this weapon dealt on the last firing"
   },
   "GetWeaponBeamReflected": {
      "documentation": [
         "bool GetWeaponBeamReflected(int weaponId, int teamId)",
         "local result = GetWeaponBeamReflected(weaponId, teamId)"
      ],
      "description": "Queries whether the beam was reflected during the last firing"
   },
   "GetWeaponCount": {
      "documentation": [
         "int GetWeaponCount(int teamId)",
         "local count = GetWeaponCount(teamId)"
      ],
      "description": "Gets the number of weapons on a given team (not including devices)\nreturns: the number of weapons on teamId\nSee also: GetWeaponId"
   },
   "GetWeaponCountSide": {
      "documentation": [
         "int GetWeaponCountSide(int sideId)",
         "local count = GetWeaponCountSide(sideId)"
      ],
      "description": "Get the number of weapon on a given side\nreturns: the number of weapons on sideId\nSee also: GetWeaponIdSide"
   },
   "GetWeaponFieldsBlockFiring": {
      "documentation": [
         "bool GetWeaponFieldsBlockFiring(int deviceId)",
         "local result = GetWeaponFieldsBlockFiring(deviceId)"
      ],
      "description": "Queries whether a weapon can be blocked by fields that block fire"
   },
   "GetWeaponFireCost": {
      "documentation": [
         "::Value GetWeaponFireCost(int id)",
         "local result = GetWeaponFireCost(id)"
      ],
      "description": "Query the cost of firing the given weapon\nBeam weapons will report the rate of resource consumption per second"
   },
   "GetWeaponFiringTimeRemaining": {
      "documentation": [
         "float GetWeaponFiringTimeRemaining(int deviceId)",
         "local result = GetWeaponFiringTimeRemaining(deviceId)"
      ],
      "description": "Queries how long a weapon still has to fire"
   },
   "GetWeaponHardpointPosition": {
      "documentation": [
         "Vector3D GetWeaponHardpointPosition(int deviceId)",
         "local result = GetWeaponHardpointPosition(deviceId)"
      ],
      "description": "Queries the position of where the weapon spawns projectiles\nSee also: GetDevicePosition, GetDeviceCentrePosition, GetWeaponBarrelPosition"
   },
   "GetWeaponId": {
      "documentation": [
         "int GetWeaponId(int teamId, int index)",
         "local id = GetWeaponId(teamId, index)"
      ],
      "description": "Query the id for a particular weapon at index on a team\nUse GetWeaponCount to get suitable values for index (zero based)\nreturns: the id of the weapon at index\nSee also: GetWeaponCount"
   },
   "GetWeaponIdSide": {
      "documentation": [
         "int GetWeaponIdSide(int sideId, int index)",
         "local id = GetWeaponIdSide(sideId, index)"
      ],
      "description": "Query the id for a particular weapon at index on a side (1 or 2)\nUse GetWeaponCount to get suitable values for index (zero based)\nreturns: the id of the weapon at index\nSee also: GetWeaponCountSide"
   },
   "GetWeaponMaxFireSpeed": {
      "documentation": [
         "float GetWeaponMaxFireSpeed(int teamId, const char* saveName)",
         "local result = GetWeaponMaxFireSpeed(teamId, saveName)"
      ],
      "description": "Query the maximum speed projectiles are launched from a weapon (with the commander inactive)\nReturns the speed for the first ammo only, if there is more than one"
   },
   "GetWeaponMinFireSpeed": {
      "documentation": [
         "float GetWeaponMinFireSpeed(int teamId, const char* saveName)",
         "local result = GetWeaponMinFireSpeed(teamId, saveName)"
      ],
      "description": "Query the minimum speed projectiles are launched from a weapon (with the commander inactive)\nReturns the speed for the first ammo only, if there is more than one"
   },
   "GetWeaponPaintTargetMarked": {
      "documentation": [
         "bool GetWeaponPaintTargetMarked(int id)",
         "local result = GetWeaponPaintTargetMarked(id)"
      ],
      "description": "Query if the weapon's target was reached by a spotting laser\nSee also: SetWeaponPaintTarget, FireWeapon"
   },
   "GetWeaponReloadPeriod": {
      "documentation": [
         "float GetWeaponReloadPeriod(int teamId, const char* saveName)",
         "local reloadPeriod = GetWeaponReloadPeriod(teamId, saveName)"
      ],
      "description": "Query the given weapon type's base reload period\nThis will be inaccurate if the weapon is using ammo which overrides ReloadTime\nreturns: the time it takes to reload, in seconds\nSee also: GetWeaponReloadPeriodById"
   },
   "GetWeaponReloadPeriodById": {
      "documentation": [
         "float GetWeaponReloadPeriodById(int id)",
         "local reloadPeriod = GetWeaponReloadPeriodById(id)"
      ],
      "description": "Query a specific weapon's reload period\nThis takes into account recently used ammo\nreturns: the time it takes to reload, in seconds\nSee also: GetWeaponReloadPeriod"
   },
   "GetWeaponReloadTime": {
      "documentation": [
         "float GetWeaponReloadTime(int id)",
         "local result = GetWeaponReloadTime(id)"
      ],
      "description": "Query how far into the reload cycle a weapon is\nreturns the value of GetWeaponReloadPeriodById if it's fully reloaded\nSee also: GetWeaponReloadPeriodById, GetWeaponReloadPeriod, SetWeaponReloadTime"
   },
   "GetWeaponSelectedAmmo": {
      "documentation": [
         "const char* GetWeaponSelectedAmmo(int deviceId)",
         "local result = GetWeaponSelectedAmmo(deviceId)"
      ],
      "description": "Queries the projectile SaveName of the ammo the weapon is set to fire"
   },
   "GetWeaponSelectedAmmoMode": {
      "documentation": [
         "int GetWeaponSelectedAmmoMode(int deviceId)",
         "local index = GetWeaponSelectedAmmoMode(deviceId)"
      ],
      "description": "Queries the selected ammo mode or type index of the weapon\nreturns: The ammo index the weapon is set to fire (also returns AMMO_MODE_PRIORITY(-2) and AMMO_MODE_QUEUE(-1))"
   },
   "GetWeaponTypeAmmoConsumeByIndex": {
      "documentation": [
         "bool GetWeaponTypeAmmoConsumeByIndex(int index, Owner teamId, int ammoIndex, int deviceIndex)",
         "local result = GetWeaponTypeAmmoConsumeByIndex(index, teamId, ammoIndex, deviceIndex)"
      ],
      "description": "Query the consume flag an ammo device this weapon requires\n'Consume' means when the ammo type is fired, the ammo device is destroyed\nammoIndex: the index of the ammo (0 for default ammo) \nSee also: GetWeaponTypeAmmoCount, GetWeaponTypeAmmoDeviceCountByIndex"
   },
   "GetWeaponTypeAmmoContextSpriteByIndex": {
      "documentation": [
         "const char* GetWeaponTypeAmmoContextSpriteByIndex(int index, Owner teamId, int ammoIndex)",
         "local result = GetWeaponTypeAmmoContextSpriteByIndex(index, teamId, ammoIndex)"
      ],
      "description": "Query the context menu sprite name representing an ammo type of a weapon\nammoIndex: the index of the ammo (0 for default ammo) \nSee also: GetWeaponTypeAmmoCount"
   },
   "GetWeaponTypeAmmoCount": {
      "documentation": [
         "int GetWeaponTypeAmmoCount(int index, Owner teamId)",
         "local ammoCount = GetWeaponTypeAmmoCount(index, teamId)"
      ],
      "description": "Queries the number of ammo types a weapon has\nreturns: the number ammo types of this weapon index\nSee also: GetDeviceTypeCount, GetWeaponTypeAmmoTagByIndex, GetWeaponTypeAmmoProjectileByIndex, GetWeaponTypeAmmoDeviceCountByIndex, GetWeaponTypeAmmoDeviceByIndex, GetWeaponTypeAmmoConsumeByIndex, GetWeaponTypeAmmoContextSpriteByIndex"
   },
   "GetWeaponTypeAmmoDeviceByIndex": {
      "documentation": [
         "const char* GetWeaponTypeAmmoDeviceByIndex(int index, Owner teamId, int ammoIndex, int deviceIndex)",
         "local result = GetWeaponTypeAmmoDeviceByIndex(index, teamId, ammoIndex, deviceIndex)"
      ],
      "description": "Query the SaveName of an ammo device this weapon requires\nammoIndex: the index of the ammo (0 for default ammo) \nSee also: GetWeaponTypeAmmoCount, GetWeaponTypeAmmoDeviceCountByIndex"
   },
   "GetWeaponTypeAmmoDeviceCountByIndex": {
      "documentation": [
         "int GetWeaponTypeAmmoDeviceCountByIndex(int index, Owner teamId, int ammoIndex)",
         "local result = GetWeaponTypeAmmoDeviceCountByIndex(index, teamId, ammoIndex)"
      ],
      "description": "Query the number of devices required by an ammo type for device at index\nOnly one device type needs to exist to satisfy the ammo type\nSee also: GetWeaponTypeAmmoCount, GetWeaponTypeAmmoDeviceByIndex, GetWeaponTypeAmmoConsumeByIndex"
   },
   "GetWeaponTypeAmmoProjectileByIndex": {
      "documentation": [
         "const char* GetWeaponTypeAmmoProjectileByIndex(int index, Owner teamId, int ammoIndex)",
         "local result = GetWeaponTypeAmmoProjectileByIndex(index, teamId, ammoIndex)"
      ],
      "description": "Query the SaveName of the ammo projectile this weapon spawns\nammoIndex: the index of the ammo (0 for default ammo) \nSee also: GetWeaponTypeAmmoCount"
   },
   "GetWeaponTypeAmmoTagByIndex": {
      "documentation": [
         "const char* GetWeaponTypeAmmoTagByIndex(int index, Owner teamId, int ammoIndex)",
         "local result = GetWeaponTypeAmmoTagByIndex(index, teamId, ammoIndex)"
      ],
      "description": "Query the ammo Tag of a weapon\nammoIndex: the index of the ammo (0 for default ammo) \nSee also: GetWeaponTypeAmmoCount"
   },
   "GetWeaponTypeFireCost": {
      "documentation": [
         "::Value GetWeaponTypeFireCost(const char* saveName)",
         "local result = GetWeaponTypeFireCost(saveName)"
      ],
      "description": "Query the default cost of firing the given weapon type\nBeam weapons will report the rate of resource consumption per second\nNot accurate if the selected ammo firing cost differs"
   },
   "GetWeaponTypeFireDelay": {
      "documentation": [
         "float GetWeaponTypeFireDelay(const char* saveName, int teamId)",
         "local delay = GetWeaponTypeFireDelay(saveName, teamId)"
      ],
      "description": "Queries the fire delay of the weapon\nreturns: 0 if not found"
   },
   "GetWeaponTypeProjectileSpeed": {
      "documentation": [
         "float GetWeaponTypeProjectileSpeed(const char* saveName)",
         "local maxSpeed = GetWeaponTypeProjectileSpeed(saveName)"
      ],
      "description": "Queries the maximum fire speed of a projectile\nreturns: 1 if not found, and logs console error"
   },
   "GetWeaponTypeRoundsEachBurst": {
      "documentation": [
         "int GetWeaponTypeRoundsEachBurst(const char* saveName, int teamId)",
         "local rounds = GetWeaponTypeRoundsEachBurst(saveName, teamId)"
      ],
      "description": "Queries the rounds per burst of the weapon\nreturns: 1 if not found"
   },
   "GetWeaponTypeRoundsPeriod": {
      "documentation": [
         "float GetWeaponTypeRoundsPeriod(const char* saveName, int teamId)",
         "local period = GetWeaponTypeRoundsPeriod(saveName, teamId)"
      ],
      "description": "Queries the rounds period of the weapon\nreturns: 0 if not found"
   },
   "IsCloaked": {
      "documentation": [
         "bool IsCloaked(int id)",
         "local result = IsCloaked(id)"
      ],
      "description": "Query whether the device or weapon is currently hidden to the enemy"
   },
   "IsDeviceAvailable": {
      "documentation": [
         "bool IsDeviceAvailable(int deviceId)",
         "local result = IsDeviceAvailable(deviceId)"
      ],
      "description": "Determines if a device is not being used by a player"
   },
   "IsDeviceBeam": {
      "documentation": [
         "bool IsDeviceBeam(int deviceId)",
         "local result = IsDeviceBeam(deviceId)"
      ],
      "description": "Queries whether the given device is a weapon with a beam ammo type selected\nOnly inspects the current ammo type of the device"
   },
   "IsDeviceFullyBuilt": {
      "documentation": [
         "bool IsDeviceFullyBuilt(int deviceId)",
         "local fullyBuilt = IsDeviceFullyBuilt(deviceId)"
      ],
      "description": "Queries the construction state of a device\nreturns: true if the device is constructed"
   },
   "IsDeviceRepairable": {
      "documentation": [
         "bool IsDeviceRepairable(int deviceId)",
         "local result = IsDeviceRepairable(deviceId)"
      ],
      "description": "Queries whether the device can be repaired"
   },
   "IsDeviceTypeAmmo": {
      "documentation": [
         "bool IsDeviceTypeAmmo(const char* saveName, Owner teamId)",
         "local result = IsDeviceTypeAmmo(saveName, teamId)"
      ],
      "description": "Queries whether the given device type is ammo"
   },
   "IsDeviceTypeAWeapon": {
      "documentation": [
         "bool IsDeviceTypeAWeapon(const char* saveName, Owner sideId)",
         "local result = IsDeviceTypeAWeapon(saveName, sideId)"
      ],
      "description": "Queries whether a device index is a weapon\nSee also: GetDeviceTypeSaveNameByIndex"
   },
   "IsDeviceTypeBeam": {
      "documentation": [
         "bool IsDeviceTypeBeam(const char* saveName, Owner teamId)",
         "local result = IsDeviceTypeBeam(saveName, teamId)"
      ],
      "description": "Queries whether the given device's default ammo type is a beam\nOnly inspects the first ammo type of the device"
   },
   "IsDeviceTypeWeapon": {
      "documentation": [
         "bool IsDeviceTypeWeapon(const char* saveName)",
         "local result = IsDeviceTypeWeapon(saveName)"
      ],
      "description": "Returns true if the given device type is a weapon"
   },
   "IsDeviceUnderConstruction": {
      "documentation": [
         "bool IsDeviceUnderConstruction(int deviceId)",
         "local underConstruction = IsDeviceUnderConstruction(deviceId)"
      ],
      "description": "Queries whether a device is under construction\nWill return false if the device is built, under repair or being scrapped\nreturns: true if the device is under construction"
   },
   "IsDummy": {
      "documentation": [
         "bool IsDummy(int deviceId)",
         "local result = IsDummy(deviceId)"
      ],
      "description": "Query whether the device or weapon is fake"
   },
   "IsGroundDevice": {
      "documentation": [
         "bool IsGroundDevice(int deviceId)",
         "local result = IsGroundDevice(deviceId)"
      ],
      "description": "Queries whether a device can only be built on the ground"
   },
   "IsSpotter": {
      "documentation": [
         "bool IsSpotter(const char* deviceSaveName, Owner sideId)",
         "local result = IsSpotter(deviceSaveName, sideId)"
      ],
      "description": "Does this device type on this side operate as a spotter (e.g. sniper)\nSpotters can increase the aiming arc of other weapons and paint targets for weapons that need it\nSee also: RequiresSpotter"
   },
   "IsWeapon": {
      "documentation": [
         "bool IsWeapon(int deviceId)",
         "local result = IsWeapon(deviceId)"
      ],
      "description": "Returns true if the given device is a weapon"
   },
   "IsWeaponReadyToFire": {
      "documentation": [
         "bool IsWeaponReadyToFire(int deviceId)",
         "local result = IsWeaponReadyToFire(deviceId)"
      ],
      "description": "Queries whether a weapon is ready to fire"
   },
   "IsWeaponSpotting": {
      "documentation": [
         "bool IsWeaponSpotting(int id)",
         "local result = IsWeaponSpotting(id)"
      ],
      "description": "Query if the specified weapon is spotting a target for another weapon"
   },
   "MoveDevice": {
      "documentation": [
         "int MoveDevice(int movingDeviceId, int nodeIdA, int nodeIdB, float t)",
         "local result = MoveDevice(movingDeviceId, nodeIdA, nodeIdB, t)"
      ],
      "description": "Moves a device on the specified platform\nSets a value for GetBlockingDevice when return value is CS_OBSTRUCTION or CD_OCCUPIED\nCan fail with CD_SOURCENOTFOUND and CD_SOURCENOTOWNED\nmovingDeviceId: the id of the device to move \nnodeIdA: the first node id of the destination platform \nnodeIdB: the second node id of the destination platform \nt: the position on the platform to make the device [0-1] \nSee also: MoveGroundDevice, CreateDevice, DestroyDevice, DestroyDeviceById"
   },
   "MoveGroundDevice": {
      "documentation": [
         "int MoveGroundDevice(int movingDeviceId, const Vector3D& position, float angle)",
         "local result = MoveGroundDevice(movingDeviceId, position, angle)"
      ],
      "description": "Moves a device on the ground\nThe position must be on suitable terrain within range of a fort\nSets a value for GetBlockingDevice when return value is CS_OBSTRUCTION or CD_OCCUPIED\nCan fail with CD_SOURCENOTFOUND and CD_SOURCENOTOWNED\nmovingDeviceId: the id of the device being moved \nposition: the location to place the device (must be on the ground) \nangle: in degrees with 90 pointing up \nSee also: MoveDevice, CreateGroundDevice, DestroyDevice, DestroyDeviceById, GetBlockingDevice"
   },
   "NarrowVisibleAnglesBySegment": {
      "documentation": [
         "int NarrowVisibleAnglesBySegment(int weaponId, const Vector3D& pos1, const Vector3D& pos2)",
         "local count = NarrowVisibleAnglesBySegment(weaponId, pos1, pos2)"
      ],
      "description": "Removes visible angle which are not in the direction of the given line segment\nFindVisibleAngles should be used before this to set up the weapon's visible angles\nweaponId: The weapon being inspected \nsideId: The side to narrow to \nreturns: The number of angle brackets remaining\nSee also: FindVisibleAngles, NarrowVisibleAnglesBySide, GetVisibleAngleBracket"
   },
   "NarrowVisibleAnglesBySide": {
      "documentation": [
         "int NarrowVisibleAnglesBySide(int weaponId, int sideId)",
         "local count = NarrowVisibleAnglesBySide(weaponId, sideId)"
      ],
      "description": "Removes visible angle which are not in the direction of a side's structures\nFindVisibleAngles should be used before this to set up the weapon's visible angles\nweaponId: The weapon being inspected \nsideId: The side to narrow to \nreturns: The number of angle brackets remaining\nSee also: FindVisibleAngles, NarrowVisibleAnglesBySegment, GetVisibleAngleBracket"
   },
   "ReloadWeapon": {
      "documentation": [
         "void ReloadWeapon(int deviceId)",
         "ReloadWeapon(deviceId)"
      ],
      "description": "Instantly reloads the given weapon"
   },
   "RepairDevice": {
      "documentation": [
         "void RepairDevice(int deviceId)",
         "RepairDevice(deviceId)"
      ],
      "description": "Starts the repair process of the given device"
   },
   "RequiresSpotter": {
      "documentation": [
         "bool RequiresSpotter(const char* deviceSaveName, Owner teamId)",
         "local result = RequiresSpotter(deviceSaveName, teamId)"
      ],
      "description": "Query whether this weapon type require a spotter with line of sight to the target"
   },
   "ReserveWeaponAim": {
      "documentation": [
         "void ReserveWeaponAim(int id, float duration)",
         "ReserveWeaponAim(id, duration)"
      ],
      "description": "Prevents the weapon's aim jumping back to the refire angle for the duration"
   },
   "SetDeviceAngle": {
      "documentation": [
         "void SetDeviceAngle(int deviceId, float angle)",
         "SetDeviceAngle(deviceId, angle)"
      ],
      "description": "Sets the angle of a ground device"
   },
   "SetDevicePopulationCap": {
      "documentation": [
         "void SetDevicePopulationCap(const char* saveName, int sideId, int populationCap)",
         "SetDevicePopulationCap(saveName, sideId, populationCap)"
      ],
      "description": "Sets the maximum number of devices or weapons a side can build"
   },
   "SetWeaponEffectTag": {
      "documentation": [
         "void SetWeaponEffectTag(int deviceId, const char* tag, bool enabled)",
         "SetWeaponEffectTag(deviceId, tag, enabled)"
      ],
      "description": "Sets the enabled/disabled state for effect tags (only supports beam impacts)\ntag: The tag for the child elements in the effects. "
   },
   "SetWeaponPaintTarget": {
      "documentation": [
         "void SetWeaponPaintTarget(int id, const Vector3D& target)",
         "SetWeaponPaintTarget(id, target)"
      ],
      "description": "Specify that a missile type weapon should target a location for an AI\nSee also: ClearWeaponPaintTarget, GetWeaponPaintTargetMarked"
   },
   "SetWeaponReloadTime": {
      "documentation": [
         "void SetWeaponReloadTime(int id, float time)",
         "SetWeaponReloadTime(id, time)"
      ],
      "description": "Sets a weapon's remaining reload time\nFireWeapon"
   },
   "SetWeaponSelectedAmmo": {
      "documentation": [
         "void SetWeaponSelectedAmmo(int deviceId, const char* tag)",
         "SetWeaponSelectedAmmo(deviceId, tag)"
      ],
      "description": "Sets the selected ammo type for a weapon by tag\ntag: The unique tag for the ammo. If the tag can't be found in the ammunition list, it will check against ammo projectile names. an empty tag will choose the first (default) ammo "
   },
   "SetWeaponSelectedAmmoMode": {
      "documentation": [
         "void SetWeaponSelectedAmmoMode(int deviceId, int index)",
         "SetWeaponSelectedAmmoMode(deviceId, index)"
      ],
      "description": "Sets the selected ammo type for a weapon by index\nNo action if the index is invalid\ntag: The index for the ammo (also accepts AMMO_MODE_PRIORITY(-2) and AMMO_MODE_QUEUE(-1)) "
   },
   "UpgradeDevice": {
      "documentation": [
         "int UpgradeDevice(int deviceId, const char* upgradeSaveName)",
         "local result = UpgradeDevice(deviceId, upgradeSaveName)"
      ],
      "description": "Converts the device or weapon to the specified device, if compatible\nreturns the new deviceId if successful, or otherwise one of the UD_* failure codes"
   },
   "AddDeviceNodeEffect": {
      "documentation": [
         "void AddDeviceNodeEffect(int sideId, const char* saveName, const char* nodeName, const char* effectPath, bool automatic)",
         "AddDeviceNodeEffect(sideId, saveName, nodeName, effectPath, automatic)"
      ],
      "description": "Attaches an effect to a node of a device or weapon\nsideId: which side to affect (1 or 2) \nsaveName: the internal name of the device or weapon \nnodeName: the name of the part to attach to \neffectPath: the file path of the effect \nautomatic: enables and keeps the effect running (otherwise it's set up but won't run) \nSee also: ConfigureDeviceNodeEffect"
   },
   "AddToEffectLifeSpan": {
      "documentation": [
         "float AddToEffectLifeSpan(unsigned int id, float duration)",
         "local result = AddToEffectLifeSpan(id, duration)"
      ],
      "description": "Adds to the life span of the effect with the given id, returns new life span\nSee also: SpawnEffect, SpawnCircle, SpawnLine"
   },
   "AttachEffectToControl": {
      "documentation": [
         "void AttachEffectToControl(const char* parent, const char* name, unsigned int effectId)",
         "AttachEffectToControl(parent, name, effectId)"
      ],
      "description": "Attaches an effect so it is drawn after the control\neffectId: the id returned from SpawnEffect \nSee also: SpawnEffect"
   },
   "CancelEffect": {
      "documentation": [
         "void CancelEffect(unsigned int id)",
         "CancelEffect(id)"
      ],
      "description": "Destroys the effect with the given id\nSee also: SpawnEffect"
   },
   "ConfigureDeviceNodeEffect": {
      "documentation": [
         "void ConfigureDeviceNodeEffect(int sideId, const char* saveName, const char* nodeName, bool automatic, bool actualTeam)",
         "ConfigureDeviceNodeEffect(sideId, saveName, nodeName, automatic, actualTeam)"
      ],
      "description": "Changes configuration of a previously added node effect\nsideId: which side to affect (1 or 2) \nsaveName: the internal name of the device or weapon \nnodeName: the name of the part to attach to \neffectPath: the file path of the effect \nautomatic: enables and keeps the effect running (otherwise it's set up but won't run) \nactualTeam: sideId is really the teamId, allowing a team's current devices' effects to be activated \nSee also: AddDeviceNodeEffect"
   },
   "DisableEffect": {
      "documentation": [
         "void DisableEffect(unsigned int id)",
         "DisableEffect(id)"
      ],
      "description": "Prevents the effect with the given id spawning more particles, trail, etc.\nSee also: SpawnEffect"
   },
   "EnableStartGameEffect": {
      "documentation": [
         "void EnableStartGameEffect(bool enable)",
         "EnableStartGameEffect(enable)"
      ],
      "description": "Turns on or off the horn sound at the start of a battle"
   },
   "LightAll": {
      "documentation": [
         "void LightAll(const Colour& col, bool pulse)",
         "LightAll(col, pulse)"
      ],
      "description": "Changes the colour of all AlienFX lights, with optional pulsing"
   },
   "MuteAllSounds": {
      "documentation": [
         "void MuteAllSounds(bool pause)",
         "MuteAllSounds(pause)"
      ],
      "description": "Pauses all sounds\nUsed to suspend sounds while playing a movie mid-battle"
   },
   "SetEffectDirection": {
      "documentation": [
         "bool SetEffectDirection(unsigned int id, const Vector3D& direction)",
         "local found = SetEffectDirection(id, direction)"
      ],
      "description": "Changes the direction of the effect with the given id\nreturns: true if the effect was found\nSee also: SpawnEffect, SetEffectPosition"
   },
   "SetEffectPosition": {
      "documentation": [
         "bool SetEffectPosition(unsigned int id, const Vector3D& position)",
         "local found = SetEffectPosition(id, position)"
      ],
      "description": "Moves the effect with the given id\nreturns: true if the effect was found\nSee also: SpawnEffect, SetEffectDirection"
   },
   "SpawnEffect": {
      "documentation": [
         "unsigned int SpawnEffect(const char* filename, const Vector3D& pos)",
         "local id = SpawnEffect(\"effects/mushroom_cloud.lua\", GetDevicePosition(deviceId))"
      ],
      "description": "Spawns an effect of the given name\nreturns: the effect id which can be passed to effect manipulation functions\nSee also: SpawnEffectEx, CancelEffect, DisableEffect, SetEffectPosition, SetEffectDirection, AddToEffectLifeSpan"
   },
   "SpawnEffectEx": {
      "documentation": [
         "unsigned int SpawnEffectEx(const char* filename, const Vector3D& pos, const Vector3D& dir)",
         "local id = SpawnEffectEx(\"effects/mushroom_cloud.lua\", GetDevicePosition(deviceId), Vec3(1, 0))"
      ],
      "description": "Spawns an effect of the given name (with extended options)\nreturns: The effect id which can be passed to effect manipulation functions\nSee also: SpawnEffect, CancelEffect, DisableEffect, SetEffectPosition, SetEffectDirection, AddToEffectLifeSpan"
   },
   "GetEnvironmentPath": {
      "documentation": [
         "const char* GetEnvironmentPath()",
         "local result = GetEnvironmentPath()"
      ],
      "description": "Query the current environment path\nUseful for constructing texture names for SetBlockTexture\nE.g. returns \"environment/canyon\"\nSee also: SetBlockTexture, GetMapFilename, GetEnvironmentPathBase"
   },
   "GetEnvironmentPathBase": {
      "documentation": [
         "const char* GetEnvironmentPathBase()",
         "local result = GetEnvironmentPathBase()"
      ],
      "description": "Query the current environment path base\nUseful for constructing texture names for SetBlockTexture\nE.g. returns \"environment/canyon\"\nSee also: SetBlockTexture, GetEnvironmentPath"
   },
   "SetBackgroundLayerFade": {
      "documentation": [
         "void SetBackgroundLayerFade(const char* layerName, float fadeAlpha, float fadeTime)",
         "SetBackgroundLayerFade(layerName, fadeAlpha, fadeTime)"
      ],
      "description": "Set the fade in/out time for a background layer"
   },
   "SetBackgroundLayerSpriteState": {
      "documentation": [
         "void SetBackgroundLayerSpriteState(const char* layerName, const char* state, bool keepTime)",
         "SetBackgroundLayerSpriteState(layerName, state, keepTime)"
      ],
      "description": "layerName: name of the layer \nstate: new sprite state \nkeepTime: transfer current state time to new state "
   },
   "ExecuteInScript": {
      "documentation": [
         "void ExecuteInScript(const char* filename, int teamId, const char* instruction)",
         "ExecuteInScript(\"ai/ai.lua\", 2, \"data.Disable = true\")"
      ],
      "description": "Run Lua instruction immediately in the script with the given filename and teamId\nWill not turn a non-deterministic event into a deterministic one. For this use SendScriptEvent instead.\nThis can't easily differentiate different mod scripts since they may have the same filename, script.lua.\nfilename: the filename of the script \nteamId: the team the script can control - one of the TEAM_* values from forts.lua \ninstruction: fully formed Lua script \nSee also: SendScriptEvent"
   },
   "SendScriptEvent": {
      "documentation": [
         "void SendScriptEvent(const char* functionName, const char* params, const char* scriptName, bool toSelf)",
         "SendScriptEvent(\"Log\", [[\"Hello, world!\"]], \"script.lua\", true)"
      ],
      "description": "Run a Lua function with given parameters on all game instances simultaneously\nCan be used to make non-deterministic events deterministic, such as user input\nfunctionName: the name of the function to call \nparams: the parameters to use as represented by a string, not including parentheses \nscriptName: the name of the script to call the function on. When empty all scripts are attempted. \ntoSelf: mods can pass true to run it only for their script \nSee also: OnKey, OnControlActivated"
   },
   "AddForcedObserverFOW": {
      "documentation": [
         "void AddForcedObserverFOW(int teamId)",
         "AddForcedObserverFOW(teamId)"
      ],
      "description": "Force FOW for observers and replays"
   },
   "EnableFogOfWar": {
      "documentation": [
         "void EnableFogOfWar(int teamId, bool enable)",
         "EnableFogOfWar(teamId, enable)"
      ],
      "description": "Shows or hides the insides of a side to the enemy"
   },
   "EnableFogOfWarShowArmour": {
      "documentation": [
         "void EnableFogOfWarShowArmour(int teamId, bool enable)",
         "EnableFogOfWarShowArmour(teamId, enable)"
      ],
      "description": "Shows or hides the armour, shields, etc. of a side to the enemy"
   },
   "FogOfWarIgnoreGameOver": {
      "documentation": [
         "void FogOfWarIgnoreGameOver(bool ignore)",
         "FogOfWarIgnoreGameOver(ignore)"
      ],
      "description": "Turns on or off fog of war removal at the end of battle"
   },
   "SetSideVisible": {
      "documentation": [
         "void SetSideVisible(int sideId, bool visible)",
         "SetSideVisible(sideId, visible)"
      ],
      "description": "Shows or hides the forts of a side (i.e. cloaking)"
   },
   "AddMouseAccessory": {
      "documentation": [
         "void AddMouseAccessory(const char* name, const char* sprite, float offsetX, float offsetY, float sizeX, float sizeY)",
         "AddMouseAccessory(name, sprite, offsetX, offsetY, sizeX, sizeY)"
      ],
      "description": "Attach a sprite to the mouse cursor\nSee also: DeleteMouseAccessory"
   },
   "DeleteMouseAccessory": {
      "documentation": [
         "void DeleteMouseAccessory(const char* name)",
         "DeleteMouseAccessory(name)"
      ],
      "description": "Delete an accessory called 'name' attached with AddMouseAccessory\nSee also: AddMouseAccessory"
   },
   "Deselect": {
      "documentation": [
         "void Deselect()",
         "Deselect()"
      ],
      "description": "Causes the player to lose any current selection"
   },
   "GetGroupMemberId": {
      "documentation": [
         "int GetGroupMemberId(int index, int memberIndex)",
         "local id = GetGroupMemberId(index, memberIndex)"
      ],
      "description": "Query the device id of the member a the group\nindex: the index of the group, corresponding to the number keys, starting at 0 \nmemberIndex: the index of the member within the group, starting at 0 \nreturns: the device id of the weapon (0 if not found)\nSee also: GetGroupSize"
   },
   "GetGroupSize": {
      "documentation": [
         "int GetGroupSize(int index)",
         "local result = GetGroupSize(index)"
      ],
      "description": "Query the current size of the group at this index\nindex: the index of the group, corresponding to the number keys, starting at 0 \nSee also: GetGroupMemberId"
   },
   "GetMouseAiming": {
      "documentation": [
         "bool GetMouseAiming()",
         "local result = GetMouseAiming()"
      ],
      "description": "Query whether the player is currently aiming"
   },
   "HideHUDOnRevert": {
      "documentation": [
         "void HideHUDOnRevert()",
         "HideHUDOnRevert()"
      ],
      "description": "Automatically hides the HUD after the player restarts the battle"
   },
   "IsFireAlarmOn": {
      "documentation": [
         "bool IsFireAlarmOn()",
         "local result = IsFireAlarmOn()"
      ],
      "description": "Returns true if the fire alarm is on for the local player"
   },
   "OpenHUDTab": {
      "documentation": [
         "void OpenHUDTab(const char* name)",
         "OpenHUDTab(\"tech\")"
      ],
      "description": "Gives focus to a tab on the HUD\nname: one of \"materials\", \"devices\", \"tech\", \"weapons\" or \"ammo\" "
   },
   "SelectDeviceType": {
      "documentation": [
         "void SelectDeviceType(const char* saveName, bool dummy)",
         "SelectDeviceType(saveName, dummy)"
      ],
      "description": "Changes the device type selection for the player"
   },
   "SetInspectedEnemyTeamId": {
      "documentation": [
         "void SetInspectedEnemyTeamId(int teamId)",
         "SetInspectedEnemyTeamId(teamId)"
      ],
      "description": "Sets the team that Spook is currently spying on, highlighting their reactor"
   },
   "SetReactorButtonEnabled": {
      "documentation": [
         "void SetReactorButtonEnabled(int index, bool enabled)",
         "SetReactorButtonEnabled(index, enabled)"
      ],
      "description": "Enables or disables the button which jumps to a particular reactor\nindex: the index of the reactor to affect \nenabled: set to false to disable \nSee also: ShowReactorBarPanel"
   },
   "SetTruceUIVisible": {
      "documentation": [
         "void SetTruceUIVisible(int teamId, bool truceUIVisibility, bool warningEnabled)",
         "SetTruceUIVisible(teamId, truceUIVisibility, warningEnabled)"
      ],
      "description": "Sets the truce period UI visibility for a side\nteamId: team side to modify \ntruceUIVisible: truce UI Visibility \nwarningEnabled: when false suppresses the truce countdown audio warning "
   },
   "ShowBuildCostPreview": {
      "documentation": [
         "void ShowBuildCostPreview(bool show)",
         "ShowBuildCostPreview(show)"
      ],
      "description": "Show or hide the build cost preview\nSee also: ShowTransactions"
   },
   "ShowHUD": {
      "documentation": [
         "void ShowHUD(bool show, bool instant)",
         "ShowHUD(show, instant)"
      ],
      "description": "Shows or hides the HUD, with or without animation"
   },
   "ShowHUDTab": {
      "documentation": [
         "void ShowHUDTab(const char* name, bool show)",
         "ShowHUDTab(\"devices\", false)"
      ],
      "description": "Shows or hides a tab on the HUD\nname: one of \"materials\", \"devices\", \"tech\", \"weapons\" or \"ammo\" "
   },
   "ShowReactorBarPanel": {
      "documentation": [
         "void ShowReactorBarPanel(bool show)",
         "ShowReactorBarPanel(show)"
      ],
      "description": "Shows or hides the reactor panel\nSee also: SetReactorButtonEnabled"
   },
   "ShowStolenResources": {
      "documentation": [
         "void ShowStolenResources(const Value& amount)",
         "ShowStolenResources(amount)"
      ],
      "description": "Shows an amount as stolen on Spook's enemy resource HUD"
   },
   "ShowTransactions": {
      "documentation": [
         "void ShowTransactions(bool show)",
         "ShowTransactions(show)"
      ],
      "description": "Show or hide resource transactions\nSee also: ShowBuildCostPreview"
   },
   "CancelMoveToPoint": {
      "documentation": [
         "void CancelMoveToPoint()",
         "CancelMoveToPoint()"
      ],
      "description": "End an automatic move started by MoveMouseToPoint\nSee also: MoveMouseToPoint"
   },
   "EnableCameraControls": {
      "documentation": [
         "void EnableCameraControls(bool enable)",
         "EnableCameraControls(enable)"
      ],
      "description": "Toggles player control of camera controls such as zoom and pan"
   },
   "EnableCursor": {
      "documentation": [
         "void EnableCursor(bool enable)",
         "EnableCursor(enable)"
      ],
      "description": "Shows or hides the cursor\nDoesn't work for observers"
   },
   "EnableKey": {
      "documentation": [
         "void EnableKey(const char* name, bool enable)",
         "EnableKey(\"PanUp\", false)"
      ],
      "description": "Allows or blocks a key from being registered\nDoesn't work for observers"
   },
   "EnableMouse": {
      "documentation": [
         "void EnableMouse(bool enable)",
         "EnableMouse(enable)"
      ],
      "description": "Toggle the mouse cursor"
   },
   "GetMousePos": {
      "documentation": [
         "Vector3D GetMousePos()",
         "local pos = GetMousePos()"
      ],
      "description": "Query the position of the mouse cursor\nreturns: the mouse screen position\nSee also: ScreenToWorld"
   },
   "LeftClickMouse": {
      "documentation": [
         "void LeftClickMouse()",
         "LeftClickMouse()"
      ],
      "description": "Create an artificial left mouse button click"
   },
   "LockControls": {
      "documentation": [
         "void LockControls(bool lock)",
         "LockControls(lock)"
      ],
      "description": "Prevents or allows the player to interact with the game"
   },
   "MiddleClickMouse": {
      "documentation": [
         "void MiddleClickMouse()",
         "MiddleClickMouse()"
      ],
      "description": "Create an artificial middle mouse button click"
   },
   "MoveMouseToPoint": {
      "documentation": [
         "void MoveMouseToPoint(const Vector3D& pos, float duration)",
         "MoveMouseToPoint(pos, duration)"
      ],
      "description": "Automatically move the mouse cursor from the current position to pos over duration seconds\nSee also: CancelMoveToPoint"
   },
   "ProcessedMousePos": {
      "documentation": [
         "Vector3D ProcessedMousePos()",
         "local pos = ProcessedMousePos()"
      ],
      "description": "Query the snapped position of the mouse cursor\nreturns: the position snapped to grid, ground, struts, etc.\nSee also: ScreenToWorld"
   },
   "RightClickMouse": {
      "documentation": [
         "void RightClickMouse()",
         "RightClickMouse()"
      ],
      "description": "Create an artificial right mouse button click"
   },
   "CastGroundRay": {
      "documentation": [
         "int CastGroundRay(const Vector3D& source, const Vector3D& target, int terrainFlags)",
         "local result = CastGroundRay(source, target, terrainFlags)"
      ],
      "description": "Intersects a line segment only with the terrain\nterrainFlags: one of the TERRAIN_* bit flags specified in forts.lua, used to modify which terrain blocks are \nReturns RAY_HIT_TERRAIN or RAY_HIT_NOTHING\nSee also: GetRayHitPosition"
   },
   "CastGroundRayFromWeapon": {
      "documentation": [
         "int CastGroundRayFromWeapon(int id, const Vector3D& target, int terrainFlags)",
         "local result = CastGroundRayFromWeapon(id, target, terrainFlags)"
      ],
      "description": "Intersects a line segment only with the terrain\nterrainFlags: one of the TERRAIN_* bit flags specified in forts.lua \nReturns RAY_HIT_TERRAIN or RAY_HIT_NOTHING\nSee also: GetRayHitPosition"
   },
   "CastRay": {
      "documentation": [
         "int CastRay(const Vector3D& source, const Vector3D& target, int rayFlags, int fieldBlockFlags)",
         "local result = CastRay(source, target, rayFlags, fieldBlockFlags)"
      ],
      "description": "Use GetRayHitTeamId(), GetRayHitPosition() and GetRayHitMaterialSaveName() to get more information on the collision\nIgnores background blocks\nsource: where to start ray from \ntarget: where to end \nrayFlags: RAY_DEBUG, RAY_EXCLUDE_DYNAMIC_TERRAIN, RAY_EXCLUDE_NEUTRAL only \nfieldBlockFlags: which fields to intersect (FIELD* constants in forts.lua) \nreturns: one of the ray result flags (e.g. RAY_HIT_STRUCTURE) in forts.lua\nSee also: GetRayHitTeamId, GetRayHitPosition, GetRayHitMaterialSaveName, GetRayHitDoor"
   },
   "CastRayFromDevice": {
      "documentation": [
         "int CastRayFromDevice(int deviceId, const Vector3D& target, float projectileHitPoints, int rayFlags, int fieldBlockFlags)",
         "local hitType = CastRayFromDevice(deviceId, target, projectileHitPoints, rayFlags, fieldBlockFlags)"
      ],
      "description": "Sends a ray from the centre of a device or weapon towards the target\nReports details of any collision in various GetRay* functions (see below)\nreturns: one of the RAY_HIT_* values from forts.lua\nSee also: GetRayHitTeamId, GetRayHitPosition, GetRayHitMaterialSaveName, GetRayHitLinkNodeIdA, GetRayHitLinkNodeIdB, GetRayHitDeviceId"
   },
   "GetRayHitDeviceId": {
      "documentation": [
         "int GetRayHitDeviceId()",
         "local result = GetRayHitDeviceId()"
      ],
      "description": "Returns the device id hit by the previous ray test\nSee also: CastRayFromDevice, CastRay"
   },
   "GetRayHitDoor": {
      "documentation": [
         "bool GetRayHitDoor()",
         "local result = GetRayHitDoor()"
      ],
      "description": "Returns the true if the last ray cast hit a door\nSee also: CastRayFromDevice, CastRay"
   },
   "GetRayHitLinkNodeIdA": {
      "documentation": [
         "int GetRayHitLinkNodeIdA()",
         "local result = GetRayHitLinkNodeIdA()"
      ],
      "description": "Returns the first nodeId of the previous ray test\nSee also: CastRayFromDevice, CastRay, FireWeapon, FireWeaponWithPower"
   },
   "GetRayHitLinkNodeIdB": {
      "documentation": [
         "int GetRayHitLinkNodeIdB()",
         "local result = GetRayHitLinkNodeIdB()"
      ],
      "description": "Returns the second nodeId of the previous ray test\nSee also: CastRayFromDevice, CastRay, FireWeapon, FireWeaponWithPower"
   },
   "GetRayHitMaterialSaveName": {
      "documentation": [
         "const char* GetRayHitMaterialSaveName()",
         "local result = GetRayHitMaterialSaveName()"
      ],
      "description": "Returns the hit material SaveName of the previous ray test\nSee also: CastRayFromDevice, CastRay, FireWeapon, FireWeaponWithPower"
   },
   "GetRayHitPosition": {
      "documentation": [
         "Vector3D GetRayHitPosition()",
         "local result = GetRayHitPosition()"
      ],
      "description": "Returns the hit position of the previous ray test\nSee also: CastRayFromDevice, CastGroundRay, CastGroundRayFromWeapon, CastRay, FireWeapon, FireWeaponWithPower"
   },
   "GetRayHitSideId": {
      "documentation": [
         "int GetRayHitSideId()",
         "local result = GetRayHitSideId()"
      ],
      "description": "returns the side hit during most recent call to\nSee also: CastRayFromDevice, CastGroundRay, CastGroundRayFromWeapon, CastRay, FireWeapon, FireWeaponWithPower"
   },
   "GetRayHitTeamId": {
      "documentation": [
         "int GetRayHitTeamId()",
         "local result = GetRayHitTeamId()"
      ],
      "description": "Returns the hit teamId of the previous ray test\nSee also: CastRayFromDevice, CastGroundRay, CastGroundRayFromWeapon, CastRay, FireWeapon, FireWeaponWithPower"
   },
   "LineSegNearestToPoint": {
      "documentation": [
         "Vector3D LineSegNearestToPoint(const Vector3D& start, const Vector3D& end, const Vector3D& pt)",
         "local nearestPoint = LineSegNearestToPoint(start, end, pt)"
      ],
      "description": "Calculates the position on the line segment closest to a point\nThe return value is clamped to the end points if it is beyond them\nstart: The first end-point of the line segment \nend: The second end-point of the line segment \npt: The point to find the nearest point to \nreturns: The closest point on the line segment to pt"
   },
   "AddStrings": {
      "documentation": [
         "void AddStrings(const char* filename)",
         "AddStrings(filename)"
      ],
      "description": "Load strings into string translation table\nSee also: Language, StringExists"
   },
   "Language": {
      "documentation": [
         "const char* Language()",
         "local result = Language()"
      ],
      "description": "Query the current language\nCan be used with AddStrings to localise strings\nSee also: AddStrings"
   },
   "StringExists": {
      "documentation": [
         "bool StringExists(const char* name)",
         "local result = StringExists(name)"
      ],
      "description": "Query if a string exists in the translation table\nSee also: AddStrings"
   },
   "DestroyProjectile": {
      "documentation": [
         "void DestroyProjectile(int nodeId)",
         "DestroyProjectile(nodeId)"
      ],
      "description": "Destroys the joint or projectile with the given nodeId"
   },
   "dlc2_CreateProjectile": {
      "documentation": [
         "int dlc2_CreateProjectile(const char* saveName, const char* weaponSaveName, int teamId, const Vector3D& position, const Vector3D& velocity, float lifespan)",
         "local result = dlc2_CreateProjectile(saveName, weaponSaveName, teamId, position, velocity, lifespan)"
      ],
      "description": "Spawns a projectile at an arbitrary position\nRequires the High Seas DLC (dlc2)"
   },
   "GetMissileTarget": {
      "documentation": [
         "Vector3D GetMissileTarget(int nodeId)",
         "local target = GetMissileTarget(nodeId)"
      ],
      "description": "Returns the current target of a missile projectile\nreturns: destination position of the missile (origin if not a missile)\nSee also: GetMissileTargetProjected, IsMissileAttacking"
   },
   "GetMissileTargetProjected": {
      "documentation": [
         "Vector3D GetMissileTargetProjected(int nodeId)",
         "local target = GetMissileTargetProjected(nodeId)"
      ],
      "description": "Returns the projected target of a missile projectile\nThis is the position TargetRearOffsetDistance behind the actual target (returned by GetMissileTarget)\nreturns: destination position of the missile (origin if not a missile)\nSee also: GetMissileTarget, IsMissileAttacking"
   },
   "GetNodeAge": {
      "documentation": [
         "float GetNodeAge(int nodeId)",
         "local age = GetNodeAge(nodeId)"
      ],
      "description": "Queries how long in seconds a node has lived for\nCould be a structure or projectile node\nreturns: zero if not found"
   },
   "GetNodeProjectileAgeTrigger": {
      "documentation": [
         "float GetNodeProjectileAgeTrigger(int nodeId)",
         "local result = GetNodeProjectileAgeTrigger(nodeId)"
      ],
      "description": "Queries the time after spawn at which the first age effect will be triggered"
   },
   "GetNodeProjectileDamage": {
      "documentation": [
         "float GetNodeProjectileDamage(int nodeId)",
         "local damage = GetNodeProjectileDamage(nodeId)"
      ],
      "description": "Queries the damage left on the projectile associated with a node\nDamage can be reduced by impact with structure (e.g. cannon)\nreturns: zero if not a projectile"
   },
   "GetNodeProjectileSaveName": {
      "documentation": [
         "const char* GetNodeProjectileSaveName(int nodeId)",
         "local saveName = GetNodeProjectileSaveName(nodeId)"
      ],
      "description": "Queries the type of projectile this node is\nreturns: empty string if not a projectile\nSee also: GetNodeProjectileType, GetProjectileParams, GetProjectileTypeIndex"
   },
   "GetNodeProjectileTimeRemaining": {
      "documentation": [
         "float GetNodeProjectileTimeRemaining(int nodeId)",
         "local timeRemaining = GetNodeProjectileTimeRemaining(nodeId)"
      ],
      "description": "Query the time a projectile will survive for\nreturns: time left to go, in seconds"
   },
   "GetNodeProjectileType": {
      "documentation": [
         "int GetNodeProjectileType(int nodeId)",
         "local type = GetNodeProjectileType(nodeId)"
      ],
      "description": "Queries the basic type of projectile associated with a node\nreturns: one of PROJECTILE_TYPE_* defined in forts.lua (-1 for not a projectile)\nSee also: IsNodeProjectile, GetNodeProjectileSaveName, GetProjectileTypeIndex"
   },
   "GetProjectileFieldRadius": {
      "documentation": [
         "float GetProjectileFieldRadius(const char* saveName, Owner teamId)",
         "local radius = GetProjectileFieldRadius(saveName, teamId)"
      ],
      "description": "Queries the radius of a projectile field\nreturns: zero if not a projectile"
   },
   "GetProjectileGravity": {
      "documentation": [
         "float GetProjectileGravity(int nodeId)",
         "local gravity = GetProjectileGravity(nodeId)"
      ],
      "description": "Queries the gravity of a projectile, which may be different from the map's gravity\nreturns: the vertical force component (positive is down)"
   },
   "GetProjectileId": {
      "documentation": [
         "int GetProjectileId(int sideId, int index)",
         "local nodeId = GetProjectileId(sideId, index)"
      ],
      "description": "Query the node id of a projectile at the index of a specific side\nsideId: 0, 1 or 2 \nindex: the index within the projectile nodes of this side \nreturns: -1 if the index is invalid\nSee also: ProjectileCount"
   },
   "GetProjectileParamBool": {
      "documentation": [
         "bool GetProjectileParamBool(const char* saveName, Owner teamId, const char* paramName, bool defaultValue)",
         "local result = GetProjectileParamBool(saveName, teamId, paramName, defaultValue)"
      ],
      "description": "Query a boolean property of a projectile type from projectile_list.lua\nsaveName: name of the projectile \nteamId: the team of interest \nparamName: name of the param to query "
   },
   "GetProjectileParamBoolByIndex": {
      "documentation": [
         "bool GetProjectileParamBoolByIndex(int index, Owner teamId, const char* paramName, bool defaultValue)",
         "local result = GetProjectileParamBoolByIndex(index, teamId, paramName, defaultValue)"
      ],
      "description": "Query a boolean property of a projectile type from projectile_list.lua by index\nindex: index of the projectile type \nteamId: the team of interest \nparamName: name of the param to query "
   },
   "GetProjectileParamFloat": {
      "documentation": [
         "float GetProjectileParamFloat(const char* saveName, int teamId, const char* paramName, float defaultValue)",
         "local result = GetProjectileParamFloat(saveName, teamId, paramName, defaultValue)"
      ],
      "description": "Queries a float property of a projectile type from projectile_list.lua\nsaveName: name of the projectile \nteamId: the team of interest \nparamName: name of the param to query "
   },
   "GetProjectileParamInt": {
      "documentation": [
         "int GetProjectileParamInt(const char* saveName, int teamId, const char* paramName, int defaultValue)",
         "local result = GetProjectileParamInt(saveName, teamId, paramName, defaultValue)"
      ],
      "description": "Queries an integer property of a projectile type from projectile_list.lua\nsaveName: name of the projectile \nteamId: the team of interest \nparamName: name of the param to query "
   },
   "GetProjectileParamIntByIndex": {
      "documentation": [
         "int GetProjectileParamIntByIndex(int index, int teamId, const char* paramName, int defaultValue)",
         "local result = GetProjectileParamIntByIndex(index, teamId, paramName, defaultValue)"
      ],
      "description": "Queries an integer property of a projectile type from projectile_list.lua by index\nindex: index of the projectile type \nteamId: the team of interest \nparamName: name of the param to query "
   },
   "GetProjectileParams": {
      "documentation": [
         "ProjParams GetProjectileParams(const char* saveName, int teamId)",
         "local A = GetProjectileParams(saveName, teamId)"
      ],
      "description": "Queries the information about a projectile associated with a node\nFieldType: one or more FIELD_* bit flags\nFieldRadius: the distance from the node position within which the field takes effect\nreturns: table containing the above mentioned values"
   },
   "GetProjectileParamString": {
      "documentation": [
         "const char* GetProjectileParamString(const char* saveName, int teamId, const char* paramName, const char* defaultValue)",
         "local result = GetProjectileParamString(saveName, teamId, paramName, defaultValue)"
      ],
      "description": "Queries a string property of a projectile type from projectile_list.lua\nsaveName: name of the projectile \nteamId: the team of interest \nparamName: name of the param to query "
   },
   "GetProjectileParamStringByIndex": {
      "documentation": [
         "const char* GetProjectileParamStringByIndex(int index, int teamId, const char* paramName, const char* defaultValue)",
         "local result = GetProjectileParamStringByIndex(index, teamId, paramName, defaultValue)"
      ],
      "description": "Queries a string property of a projectile type from projectile_list.lua by index\nindex: index of the projectile type \nteamId: the team of interest \nparamName: name of the param to query "
   },
   "GetProjectileTarget": {
      "documentation": [
         "Vector3D GetProjectileTarget(int nodeId)",
         "local target = GetProjectileTarget(nodeId)"
      ],
      "description": "Queries the destination of projectiles\nMissiles return their target.\nOther projectiles and nodes will return the position projected 1s into the future.\nreturns: somewhere the projectile is heading."
   },
   "GetProjectileTypeCount": {
      "documentation": [
         "int GetProjectileTypeCount(Owner teamId)",
         "local result = GetProjectileTypeCount(teamId)"
      ],
      "description": "Gets the number of projectile types for a team\nSee also: GetProjectileTypeSaveNameByIndex, GetProjectileTypeIndex"
   },
   "GetProjectileTypeDrag": {
      "documentation": [
         "float GetProjectileTypeDrag(const char* saveName, Owner teamId)",
         "local drag = GetProjectileTypeDrag(saveName, teamId)"
      ],
      "description": "Queries the drag of a projectile by type\nreturns: parameter of the projectile"
   },
   "GetProjectileTypeGravity": {
      "documentation": [
         "float GetProjectileTypeGravity(const char* saveName, Owner teamId)",
         "local gravity = GetProjectileTypeGravity(saveName, teamId)"
      ],
      "description": "Queries the gravity of a projectile by type, which may be different from the map's gravity\nreturns: the vertical force component (positive is down)"
   },
   "GetProjectileTypeIndex": {
      "documentation": [
         "int GetProjectileTypeIndex(const char* saveName, int teamId)",
         "local result = GetProjectileTypeIndex(saveName, teamId)"
      ],
      "description": "Queries the index of a projectile type from projectile_list.lua\nsaveName: name of the projectile \nteamId: the team of interest \nSee also: GetNodeProjectileSaveName, GetNodeProjectileType"
   },
   "GetProjectileTypeSaveNameByIndex": {
      "documentation": [
         "const char* GetProjectileTypeSaveNameByIndex(int index, Owner teamId)",
         "local result = GetProjectileTypeSaveNameByIndex(index, teamId)"
      ],
      "description": "Gets a projectile type SaveName for a team\nSee also: GetProjectileTypeCount"
   },
   "HasProjectileParamNodeByIndex": {
      "documentation": [
         "bool HasProjectileParamNodeByIndex(int index, int teamId, const char* nodeName)",
         "local result = HasProjectileParamNodeByIndex(index, teamId, nodeName)"
      ],
      "description": "Queries node existence of a projectile type from projectile_list.lua by index\nindex: index of the projectile type \nteamId: the team of interest \nnodeName: name of the table to query for existance "
   },
   "IsMissileAttacking": {
      "documentation": [
         "bool IsMissileAttacking(int nodeId)",
         "local false = IsMissileAttacking(nodeId)"
      ],
      "description": "Queries whether a missile projectile is in the attack phase\nreturns: if not a guided missile or rocket\nSee also: GetNodeProjectileType"
   },
   "IsNodeProjectile": {
      "documentation": [
         "bool IsNodeProjectile(unsigned int nodeId)",
         "local result = IsNodeProjectile(nodeId)"
      ],
      "description": "Query if the given node is associated with a projectile\nSee also: GetNodeProjectileType, GetNodeProjectileSaveName"
   },
   "ProjectileCount": {
      "documentation": [
         "int ProjectileCount(int sideId)",
         "local count = ProjectileCount(sideId)"
      ],
      "description": "Query the total projectile nodes belonging to a side\nsideId: 0, 1 or 2 \nreturns: the number of projectiles belonging to the team\nSee also: GetProjectileId"
   },
   "SetMissileTarget": {
      "documentation": [
         "void SetMissileTarget(int nodeId, const Vector3D& target)",
         "SetMissileTarget(nodeId, target)"
      ],
      "description": "Sets the target of a missile projectile\nSee also: GetMissileTarget, GetMissileTargetProjected"
   },
   "SetNodeProjectileAgeTrigger": {
      "documentation": [
         "void SetNodeProjectileAgeTrigger(int nodeId, float age)",
         "SetNodeProjectileAgeTrigger(nodeId, age)"
      ],
      "description": "Sets the time after spawn at which the first age effect will be triggered"
   },
   "GetPropCount": {
      "documentation": [
         "int GetPropCount()",
         "local result = GetPropCount()"
      ],
      "description": "Query the number of props in the world"
   },
   "GetPropIndex": {
      "documentation": [
         "int GetPropIndex(const char* propName)",
         "local result = GetPropIndex(propName)"
      ],
      "description": "Query the position of a prop with a specific name"
   },
   "GetPropName": {
      "documentation": [
         "const char* GetPropName(int index)",
         "local result = GetPropName(index)"
      ],
      "description": "Query the name of a prop with a given index\nSee also: GetPropCount, GetPropIndex"
   },
   "GetPropPos": {
      "documentation": [
         "Vector3D GetPropPos(int index)",
         "local result = GetPropPos(index)"
      ],
      "description": "Query the position of a prop with a given index\nSee also: GetPropCount, GetPropIndex"
   },
   "GetPropPosByName": {
      "documentation": [
         "Vector3D GetPropPosByName(const char* propName)",
         "local result = GetPropPosByName(propName)"
      ],
      "description": "Query the position of a prop with a specific name"
   },
   "IsPropType": {
      "documentation": [
         "bool IsPropType(int index, const char* type)",
         "local result = IsPropType(index, type)"
      ],
      "description": "Query whether the prop with the given index uses a texture name given by the type parameter\nSee also: GetPropCount, GetPropIndex"
   },
   "SetPropPos": {
      "documentation": [
         "void SetPropPos(int index, const Vector3D& pos)",
         "SetPropPos(index, pos)"
      ],
      "description": "Set the position of a prop with a given index\nSee also: GetPropCount, GetPropIndex"
   },
   "ShowProp": {
      "documentation": [
         "void ShowProp(const char* name, bool visible)",
         "ShowProp(name, visible)"
      ],
      "description": "Shows or hides a prop of a specific name"
   },
   "GetNormalFloat": {
      "documentation": [
         "float GetNormalFloat(float std_dev, float mean, const char* desc)",
         "local result = GetNormalFloat(std_dev, mean, desc)"
      ],
      "description": "Generate and consume a deterministic random value within the normal distribution\nUse this only for critical game state changes\nSee also: GetRandomFloat, GetRandomInteger"
   },
   "GetNormalFloatLocal": {
      "documentation": [
         "float GetNormalFloatLocal(float std_dev, float mean)",
         "local result = GetNormalFloatLocal(std_dev, mean)"
      ],
      "description": "Returns a non-deterministic random float within the normal distribution\nUse GetNormalFloat for gameplay critical values\nSee also: GetRandomFloatLocal, GetRandomIntegerLocal"
   },
   "GetRandomFloat": {
      "documentation": [
         "float GetRandomFloat(float lower, float upper, const char* desc)",
         "local delay = GetRandomFloat(3.5, 5.5, \"mymod destroy delay\")"
      ],
      "description": "Generate and consume a deterministic random value\nUse this only for critical game state changes\nlower: the lower limit of the random value \nupper: the upper limit of the random value \ndesc: a text description of the intended use, required for debugging \nreturns: a random value between lower and upper, inclusive\nSee also: GetNormalFloat, GetRandomInteger"
   },
   "GetRandomFloatLocal": {
      "documentation": [
         "float GetRandomFloatLocal(float lower, float upper)",
         "local result = GetRandomFloatLocal(lower, upper)"
      ],
      "description": "Returns a non-deterministic random float between lower and upper\nUse GetRandomFloat for gameplay critical values\nSee also: GetNormalFloatLocal, GetRandomIntegerLocal"
   },
   "GetRandomInteger": {
      "documentation": [
         "int GetRandomInteger(int lower, int upper, const char* desc)",
         "local result = GetRandomInteger(lower, upper, desc)"
      ],
      "description": "Generate and consume a deterministic random integer value between lower and upper\nUse this only for critical game state changes\nSee also: GetRandomFloat, GetNormalFloat"
   },
   "GetRandomIntegerLocal": {
      "documentation": [
         "int GetRandomIntegerLocal(int lower, int upper)",
         "local result = GetRandomIntegerLocal(lower, upper)"
      ],
      "description": "Returns a non-deterministic random integer between lower and upper\nUse GetRandomInteger for gameplay critical values\nSee also: GetRandomFloatLocal, GetNormalFloatLocal"
   },
   "AddResources": {
      "documentation": [
         "void AddResources(int teamId, const Value& amount, bool hasPos, const Vector3D& pos)",
         "AddResources(teamId, amount, hasPos, pos)"
      ],
      "description": "Increment the given team's balance by value\namount: can be negative to spend resources "
   },
   "EnableProduction": {
      "documentation": [
         "void EnableProduction(bool enable)",
         "EnableProduction(enable)"
      ],
      "description": "Enables or disables devices produces resources\nUsed during cutscenes to prevent accumulation"
   },
   "GetProductionEnabled": {
      "documentation": [
         "bool GetProductionEnabled()",
         "local result = GetProductionEnabled()"
      ],
      "description": "Queries whether resource production is enabled\nCan be affected by EnableProduction"
   },
   "GetTeamResourceCapacity": {
      "documentation": [
         "::Value GetTeamResourceCapacity(int teamId)",
         "local result = GetTeamResourceCapacity(teamId)"
      ],
      "description": "Query the current resource capacity of the given team"
   },
   "GetTeamResourceRate": {
      "documentation": [
         "::Value GetTeamResourceRate(int teamId)",
         "local result = GetTeamResourceRate(teamId)"
      ],
      "description": "Query the current resource accumulation rate of the given team\nThis is per-frame; multiply by 'FrameRate' or divide by 'data.updateDelta' to calculate per-second rates"
   },
   "SetUnlimitedResources": {
      "documentation": [
         "void SetUnlimitedResources(int teamId, bool unlimitedMetal, bool unlimitedEnergy)",
         "SetUnlimitedResources(teamId, unlimitedMetal, unlimitedEnergy)"
      ],
      "description": "Set unlimited resources and capacities for a given team\nIf unlimited[Resource] is changing from true -> false, [Resource] value and capacity are reset to default starting values (starting balance and starting capacity + device capacities)\nunlimitedMetal: set unlimited Metal \nunlimitedEnergy: set unlimited Energy \nSee also: GetTeamResources, AddResources"
   },
   "TransferResources": {
      "documentation": [
         "::Value TransferResources(int teamIdFrom, int sideIdTo, float metal, float energy)",
         "local result = TransferResources(teamIdFrom, sideIdTo, metal, energy)"
      ],
      "description": "Transfer resources from a team to a side\nThe resources are distributed evenly among the teams within the side"
   },
   "ClearSimulation": {
      "documentation": [
         "void ClearSimulation()",
         "ClearSimulation()"
      ],
      "description": "Destroys all structures, devices and projectiles"
   },
   "EnablePhysics": {
      "documentation": [
         "void EnablePhysics(bool enable)",
         "EnablePhysics(enable)"
      ],
      "description": "Enables or disables physics simulation\nUsed to suspend physics while playing a movie mid-battle"
   },
   "EndReplay": {
      "documentation": [
         "void EndReplay()",
         "EndReplay()"
      ],
      "description": "Prevents the replay recording any further gameplay\nUsed at the start of complex tutorials and when movies are played at end of battles"
   },
   "EnterGameOverMode": {
      "documentation": [
         "void EnterGameOverMode()",
         "EnterGameOverMode()"
      ],
      "description": "Prevents the player having any control and starts the end of battle process\nhas no effect if game over mode has already been set"
   },
   "Exit": {
      "documentation": [
         "void Exit(float side1Score, const char* nextMap)",
         "Exit(0, \"next\")"
      ],
      "description": "End the battle and load another\nThis is for single player only\nside1Score: obsolete (not used for anything) \nnextMap: the new map to load, can be \"next\" to advance a linear campaign "
   },
   "GetGameMode": {
      "documentation": [
         "const char* GetGameMode()",
         "local mode = GetGameMode()"
      ],
      "description": "Returns \"Multiplayer\", \"Campaign\", \"Skirmish\", \"Sandbox\", or \"Editor\"\nreturns: the current mode of the game"
   },
   "GetMapFilename": {
      "documentation": [
         "const char* GetMapFilename()",
         "local result = GetMapFilename()"
      ],
      "description": "Query the current map filename or Workshop published file Id\nE.g. returns \"Vanilla\", \"1230779210\"\nSee also: GetEnvironmentPath"
   },
   "InReplay": {
      "documentation": [
         "bool InReplay()",
         "local result = InReplay()"
      ],
      "description": "Returns true if the current game is a replay"
   },
   "IsPaused": {
      "documentation": [
         "bool IsPaused()",
         "local result = IsPaused()"
      ],
      "description": "Returns true if the game is paused"
   },
   "MakeUndoLevel": {
      "documentation": [
         "void MakeUndoLevel()",
         "MakeUndoLevel()"
      ],
      "description": "Saves the current state in an undo level\nUse this in a terraform script after making changes to make the action easy to undo"
   },
   "ModActive": {
      "documentation": [
         "bool ModActive(const char* modName)",
         "local result = ModActive(\"dlc1_weapons\")"
      ],
      "description": "Query if a specific mod is currently active"
   },
   "Pause": {
      "documentation": [
         "void Pause(bool pause)",
         "Pause(pause)"
      ],
      "description": "Pauses or resumes the battle"
   },
   "SetResult": {
      "documentation": [
         "void SetResult(int winningTeamId, bool silent)",
         "SetResult(winningTeamId, silent)"
      ],
      "description": "Sets the winning team without entering game over mode and triggering the result banner\nhas no effect if a winning team has already been set\nsilent: When true the victory and defeat music isn't played "
   },
   "SetTrucePeriod": {
      "documentation": [
         "void SetTrucePeriod(int teamId, float trucePeriod)",
         "SetTrucePeriod(teamId, trucePeriod)"
      ],
      "description": "Sets the truce period for a side\nteamId: team side to modify \ntrucePeriod: new truce period "
   },
   "ShowResult": {
      "documentation": [
         "void ShowResult(int winningTeamId)",
         "ShowResult(winningTeamId)"
      ],
      "description": "Sets the winner of the battle to winningTeamId, enters game over mode and triggers result banner\ndoes not update winning team if it has already been set\ndoes not update the result if result banner if it is already visible"
   },
   "AddPrimaryMidgroundRenderOrder": {
      "documentation": [
         "void AddPrimaryMidgroundRenderOrder(unsigned int structureId)",
         "AddPrimaryMidgroundRenderOrder(structureId)"
      ],
      "description": "Adds a midground primary structure render order override\nIf used, make sure all primary structures have been added or they will not be rendered\nstructureId: The structure id to render "
   },
   "CancelRepairLink": {
      "documentation": [
         "void CancelRepairLink(int nodeIdA, int nodeIdB)",
         "CancelRepairLink(nodeIdA, nodeIdB)"
      ],
      "description": "Stops repairing the given strut"
   },
   "ClearPrimaryMidgroundRenderOrder": {
      "documentation": [
         "void ClearPrimaryMidgroundRenderOrder()",
         "ClearPrimaryMidgroundRenderOrder()"
      ],
      "description": "Clears midground primary structure render order override"
   },
   "CloseWeaponDoors": {
      "documentation": [
         "void CloseWeaponDoors(int id)",
         "CloseWeaponDoors(id)"
      ],
      "description": "Attempts to close the doors that were previously opened by the given weapon\nSee also: OpenWeaponDoors, OpenDoor, SetDoorState"
   },
   "ConnectPortals": {
      "documentation": [
         "int ConnectPortals(int teamId, int nodeIdA, int nodeIdB, int nodeIdADest, int nodeIdBDest)",
         "local result = ConnectPortals(teamId, nodeIdA, nodeIdB, nodeIdADest, nodeIdBDest)"
      ],
      "description": "Links two portals identified by the parameters\nteamId: the teamId the nodes should be owned by \nnodeIdA: the first node of the first portal \nnodeIdB: the second node of the first portal \nnodeIdADest: the first node of the second portal \nnodeIdBDest: the second node of the second portal \nreturns: CP_SUCCESS or CP_INVALIDNODES"
   },
   "CreateLink": {
      "documentation": [
         "int CreateLink(int teamId, const char* saveName, int nodeIdA, int nodeIdB)",
         "local result = CreateLink(teamId, saveName, nodeIdA, nodeIdB)"
      ],
      "description": "Create a strut between the two given nodes"
   },
   "CreateNode": {
      "documentation": [
         "int CreateNode(int teamId, const char* materialSaveName, int linkedNodeIdA, const Vector3D& pos)",
         "local nodeId = CreateNode(teamId, materialSaveName, linkedNodeIdA, pos)"
      ],
      "description": "Create a new node at pos, linked to the node with id linkedNodeIdA\nteamId: the team to create for \nmaterialSaveName: the name of the material to use \nlinkedNodeIdA: the existing node Id to link from \npos: the position of the new node \nreturns: the node Id if the operation was successful. A negative value indicates failure with a CS_* value from forts.lua\nSee also: DestroyNode, CreateLink, GetCreateNodeGroundSnap"
   },
   "DestroyLink": {
      "documentation": [
         "void DestroyLink(int teamId, int nodeIdA, int nodeIdB)",
         "DestroyLink(teamId, nodeIdA, nodeIdB)"
      ],
      "description": "Salvage the strut between the two given nodes\nSee also: DestroyNode, CreateLink"
   },
   "DestroyNode": {
      "documentation": [
         "void DestroyNode(int teamId, int nodeId)",
         "DestroyNode(teamId, nodeId)"
      ],
      "description": "Salvage the given node and any attached struts\nThe calling script must have control of the team of the node\nteamId: the expected team of the node \nnodeId: the Id of the node to destroy \nSee also: DestroyLink"
   },
   "DestroyStructure": {
      "documentation": [
         "void DestroyStructure(int nodeId)",
         "DestroyStructure(nodeId)"
      ],
      "description": "Instantly destroy the entire structure connected to the given node"
   },
   "dlc2_ApplyForce": {
      "documentation": [
         "void dlc2_ApplyForce(int nodeId, const Vector3D& force)",
         "dlc2_ApplyForce(nodeId, force)"
      ],
      "description": "Adds a force to a joint\nRequires the High Seas DLC (dlc2)"
   },
   "dlc2_ConvertStructure": {
      "documentation": [
         "void dlc2_ConvertStructure(int structureId, int structureNodeId, int teamIdFrom, int teamIdTo)",
         "dlc2_ConvertStructure(structureId, structureNodeId, teamIdFrom, teamIdTo)"
      ],
      "description": "Convert team ownership of a structure\nRequires the High Seas DLC (dlc2)\nSee also: GetDeviceStructureId, NodeStructureId"
   },
   "EnableMaterial": {
      "documentation": [
         "void EnableMaterial(const char* saveName, bool enable, int sideId)",
         "EnableMaterial(saveName, enable, sideId)"
      ],
      "description": "Enable or disable a material for a side\nsaveName: can be \"*\" to apply to all materials "
   },
   "EnumerateChainNodes": {
      "documentation": [
         "void EnumerateChainNodes(int nodeIdA, int nodeIdB, const char* callbackName)",
         "EnumerateChainNodes(nodeIdA, nodeIdB, callbackName)"
      ],
      "description": "Follows a chain of struts in both directions, reporting nodes to a callback\nThe callback takes only the next nodeId found in the chain\nnodeIdA: the first starting node \nnodeIdB: the second starting node \ncallbackName: the name of the callback function "
   },
   "EnumerateLinks": {
      "documentation": [
         "void EnumerateLinks(int teamId, const char* callbackName, float damageThreshold, float damageThresholdDevice, const char* sourceDevice, bool matchSide)",
         "EnumerateLinks(2, \"myLinkCallback\", 1, 1, \"reactor\", true)"
      ],
      "description": "Easily enumerate struts that satisfy a damage condition\nThe callback must have:\n- parameters: nodeA [1+], nodeB [1+], saveName, relativeHealth [0-1], stress [0-1], segmentsOnFire [0+], deviceId [0+]\n- return value: true or false, indicating whether to continue the search\nIf a link has less health than damageThreshold or a device with less than damageThresholdDevice a call for the link will be made\nThis can be used to filter out healthy links and devices when searching for items to repair (for optimisation)\nTo do a breadth first enumeration from a device type (typically this will be \"reactor\"), specify in sourceDevice parameter\nOtherwise a zero length string will enumerate the links from the nodes in numerical (creation) order\nIf a strut has no device on it then the deviceId given to the callback will be 0\nStress represents how close the strut is to breaking, where 0 is no compression/expansion, and 1 is the limit\nteamId: the team/side to enumerate (see matchSide parameter) \ncallbackName: the name of the function to call for each strut found \ndamageThreshold: relative health of the strut [0-1], below which the strut will be passed to the callback \ndamageThresholdDevice: relative health of a device on the strut [0-1], below which the strut will be passed to the callback \nsourceDevice: the SaveName of a device used as the origin(s) of the search. Commonly \"reactor\", but can be empty (\"\") for numerical order. \nmatchSide: if true will search any structures on the same side as teamId "
   },
   "EnumerateStructureLinks": {
      "documentation": [
         "void EnumerateStructureLinks(int teamId, int structureId, const char* callbackName, bool matchSide)",
         "EnumerateStructureLinks(2, 1, \"myLinkCallback\", true)"
      ],
      "description": "Easily enumerate struts within a specific structure\nThe callback must have:\n- parameters: nodeA [1+], nodeB [1+], link position, saveName, deviceId [0+]\n- return value: true or false, indicating whether to continue the search\nEnumerate the links from the nodes in numerical (creation) order\nIf a strut has no device on it then the deviceId given to the callback will be 0\nteamId: the team/side to enumerate (see matchSide parameter) \nstructureId: the structure id to enumerate, -1 searches all strucure ids \ncallbackName: the name of the function to call for each strut found \nmatchSide: if true will search any structures on the same side as teamId "
   },
   "FindNodeOnStructure": {
      "documentation": [
         "int FindNodeOnStructure(const Vector3D& pos, int structureId, bool farthest)",
         "local nodeId = FindNodeOnStructure(pos, structureId, farthest)"
      ],
      "description": "Finds the selectable node id which is closest or farthest to a position on the specified structure\npos: The position to search from \nstructureId: The structure to search on (0 for all structures) \nfarthest: Find the farthest instead of the closest \nreturns: The id of the node closest to pos (-1 if structure is invalid)"
   },
   "GetClosestFoundationNodeId": {
      "documentation": [
         "int GetClosestFoundationNodeId(int teamId, const Vector3D& position)",
         "local nodeId = GetClosestFoundationNodeId(teamId, position)"
      ],
      "description": "Find the closest foundation node id of a team to a position\nThe maximumn distance is defined in constants.lua\nreturns: -1 if none found\nSee also: SnapToNode"
   },
   "GetCreateNodeGroundSnap": {
      "documentation": [
         "bool GetCreateNodeGroundSnap()",
         "local groundSnap = GetCreateNodeGroundSnap()"
      ],
      "description": "Query whether the last CreateNode call snapped to the ground and attempted to create a foundation\nreturns: true if the CreateNode call snapped to ground\nSee also: CreateNode"
   },
   "GetDefaultBackMaterial": {
      "documentation": [
         "const char* GetDefaultBackMaterial()",
         "local result = GetDefaultBackMaterial()"
      ],
      "description": "Query the material SaveName for creating background structure"
   },
   "GetDeviceState": {
      "documentation": [
         "int GetDeviceState(int deviceId)",
         "local result = GetDeviceState(deviceId)"
      ],
      "description": "Returns the state of the given device\nOne of the DEVICE_* values from forts.lua"
   },
   "GetLinkCost": {
      "documentation": [
         "Value GetLinkCost(int nodeIdA, const Vector3D& pos, const char* materialSaveName, bool addFoundation)",
         "local result = GetLinkCost(nodeIdA, pos, materialSaveName, addFoundation)"
      ],
      "description": "Returns the cost of building a new strut to the given position, with the given material"
   },
   "GetLinkCountOfSide": {
      "documentation": [
         "int GetLinkCountOfSide(int teamId)",
         "local result = GetLinkCountOfSide(teamId)"
      ],
      "description": "Returns the number of struts of the given side, e.g. 0, 1, 2\nWhen passed a specific team will convert to side\nUse GetLinkCountOfTeam() for specific team within a side"
   },
   "GetLinkCountOfTeam": {
      "documentation": [
         "int GetLinkCountOfTeam(int teamId)",
         "local result = GetLinkCountOfTeam(teamId)"
      ],
      "description": "Returns the number of struts in a specific team of a side, e.g. 1, 101, 201\nSee also: GetLinkCountOfSide"
   },
   "GetLinkHealth": {
      "documentation": [
         "float GetLinkHealth(unsigned int nodeIdA, unsigned int nodeIdB)",
         "local result = GetLinkHealth(nodeIdA, nodeIdB)"
      ],
      "description": "Get the relative health of the given strut in the range [0-1]"
   },
   "GetLinkLengthCost": {
      "documentation": [
         "Value GetLinkLengthCost(float length, const char* materialSaveName, int teamId)",
         "local result = GetLinkLengthCost(length, materialSaveName, teamId)"
      ],
      "description": "Returns the cost of building a length of the given material"
   },
   "GetLinkMaterialSaveName": {
      "documentation": [
         "const char* GetLinkMaterialSaveName(int nodeIdA, int nodeIdB)",
         "local result = GetLinkMaterialSaveName(nodeIdA, nodeIdB)"
      ],
      "description": "Query the SaveName of the material connecting two nodes"
   },
   "GetLinkRepairCost": {
      "documentation": [
         "Value GetLinkRepairCost(int nodeIdA, int nodeIdB)",
         "local result = GetLinkRepairCost(nodeIdA, nodeIdB)"
      ],
      "description": "Returns the cost of fully repairing the given strut"
   },
   "GetLinkSegmentsOnFire": {
      "documentation": [
         "int GetLinkSegmentsOnFire(int nodeIdA, int nodeIdB)",
         "local result = GetLinkSegmentsOnFire(nodeIdA, nodeIdB)"
      ],
      "description": "Returns the number of segments on fire on the given strut"
   },
   "GetLinkState": {
      "documentation": [
         "int GetLinkState(int nodeIdA, int nodeIdB)",
         "local result = GetLinkState(nodeIdA, nodeIdB)"
      ],
      "description": "Returns the state of the given strut\nOne of the LINK_* values from forts.lua"
   },
   "GetMaterialEnabled": {
      "documentation": [
         "bool GetMaterialEnabled(const char* saveName, int sideId)",
         "local result = GetMaterialEnabled(saveName, sideId)"
      ],
      "description": "Query whether a material on a side is enabled for building"
   },
   "GetMaterialMaxLength": {
      "documentation": [
         "float GetMaterialMaxLength(const char* saveName, int sideId)",
         "local result = GetMaterialMaxLength(saveName, sideId)"
      ],
      "description": "Query the maximum length of a material for a side"
   },
   "GetMaterialMaxLinkLength": {
      "documentation": [
         "float GetMaterialMaxLinkLength(const char* saveName, int sideId)",
         "local result = GetMaterialMaxLinkLength(saveName, sideId)"
      ],
      "description": "Query the maximum link length of a material for a side"
   },
   "GetMaterialMinLength": {
      "documentation": [
         "float GetMaterialMinLength(const char* saveName, int sideId)",
         "local result = GetMaterialMinLength(saveName, sideId)"
      ],
      "description": "Query the minimum length of a material for a side"
   },
   "GetNodeGroundBlockIndex": {
      "documentation": [
         "int GetNodeGroundBlockIndex(int nodeId)",
         "local blockIndex = GetNodeGroundBlockIndex(nodeId)"
      ],
      "description": "Query the block index associated with a foundation node\nreturns: -1 if no block is associated with the node"
   },
   "GetNodeId": {
      "documentation": [
         "int GetNodeId(int sideId, int index)",
         "local nodeId = GetNodeId(sideId, index)"
      ],
      "description": "Query the id at the index of a specific side\nsideId: 0, 1 or 2 \nindex: the index within the nodes of this side \nreturns: -1 if the index is invalid\nSee also: NodeCount"
   },
   "GetPortalDestinationA": {
      "documentation": [
         "int GetPortalDestinationA(int nodeIdA, int nodeIdB)",
         "local result = GetPortalDestinationA(nodeIdA, nodeIdB)"
      ],
      "description": "Returns the first node of the destination portal\nSee also: GetPortalDestinationB, IsPortal"
   },
   "GetPortalDestinationB": {
      "documentation": [
         "int GetPortalDestinationB(int nodeIdA, int nodeIdB)",
         "local result = GetPortalDestinationB(nodeIdA, nodeIdB)"
      ],
      "description": "Returns the second node of the destination portal\nSee also: GetPortalDestinationA, IsPortal"
   },
   "GetStructureCount": {
      "documentation": [
         "int GetStructureCount()",
         "local result = GetStructureCount()"
      ],
      "description": "Query the number of separate structures in the world\nEach structure gets a unique and stable id\nSee also: GetStructureTeam"
   },
   "GetStructureId": {
      "documentation": [
         "int GetStructureId(int index)",
         "local result = GetStructureId(index)"
      ],
      "description": "Query the id of a structure\nSee also: GetStructureCount, GetDeviceStructureId, NodeStructureId"
   },
   "GetStructureInWater": {
      "documentation": [
         "bool GetStructureInWater(int structureId)",
         "local onLand = GetStructureInWater(structureId)"
      ],
      "description": "Determine if a structure has a physical connection to land\nreturns: true if the structure has any part under water, excluding via non conductive materials (i.e. ropes)\nSee also: GetStructureCount, GetDeviceStructureId, NodeStructureId, GetStructureOnLand"
   },
   "GetStructureOnLand": {
      "documentation": [
         "bool GetStructureOnLand(int structureId)",
         "local onLand = GetStructureOnLand(structureId)"
      ],
      "description": "Determine if a structure has a physical connection to land\nreturns: true if the structure has any foundations, excluding via non conductive materials (i.e. ropes)\nSee also: GetStructureCount, GetDeviceStructureId, NodeStructureId, GetStructureInWater"
   },
   "GetStructurePos": {
      "documentation": [
         "Vector3D GetStructurePos(int structureId)",
         "local result = GetStructurePos(structureId)"
      ],
      "description": "Query the geometric centre of a structure\nSee also: GetStructureId, GetStructureCount, GetStructureRadius"
   },
   "GetStructureRadius": {
      "documentation": [
         "float GetStructureRadius(int structureId)",
         "local result = GetStructureRadius(structureId)"
      ],
      "description": "Query the geometric radius of a structure\nSee also: GetStructureId, GetStructureCount, GetStructurePos"
   },
   "GetStructureTeam": {
      "documentation": [
         "int GetStructureTeam(int structureId)",
         "local result = GetStructureTeam(structureId)"
      ],
      "description": "Query the teamId of a structure\nSee also: GetStructureCount, GetDeviceStructureId, NodeStructureId"
   },
   "GetTeamLinksOnFire": {
      "documentation": [
         "int GetTeamLinksOnFire(int teamId)",
         "local result = GetTeamLinksOnFire(teamId)"
      ],
      "description": "Get the number of struts on fire for the given team"
   },
   "GetTeamMinLinkHealth": {
      "documentation": [
         "float GetTeamMinLinkHealth(int teamId)",
         "local result = GetTeamMinLinkHealth(teamId)"
      ],
      "description": "Get the lowest relative strut health of the given team\nUseful for the AI to quickly determine if any struts need repairing"
   },
   "GhostStructure": {
      "documentation": [
         "void GhostStructure(int nodeId, bool ghost)",
         "GhostStructure(nodeId, ghost)"
      ],
      "description": "Toggles ghost mode on a structure containing a node"
   },
   "HighlightLink": {
      "documentation": [
         "void HighlightLink(int nodeIdA, int nodeIdB, bool highlight)",
         "HighlightLink(nodeIdA, nodeIdB, highlight)"
      ],
      "description": "Starts or stops a flashing highlight on a strut and attached cladding"
   },
   "IgniteFire": {
      "documentation": [
         "void IgniteFire(const Vector3D& pos, float radius, float radiusHeated, int teamId)",
         "IgniteFire(pos, radius, radiusHeated, teamId)"
      ],
      "description": "Sets fire to any flammable structures under a circle\nteamId: the exact team to affect. Can be TEAM_ANY. "
   },
   "IsDoor": {
      "documentation": [
         "bool IsDoor(const char* saveName, int teamId)",
         "local result = IsDoor(saveName, teamId)"
      ],
      "description": "Queries whether a material is a door type"
   },
   "IsFoundation": {
      "documentation": [
         "bool IsFoundation(int nodeId)",
         "local result = IsFoundation(nodeId)"
      ],
      "description": "Query whether a node is a foundation"
   },
   "IsLinkConductive": {
      "documentation": [
         "bool IsLinkConductive(int nodeIdA, int nodeIdB)",
         "local result = IsLinkConductive(nodeIdA, nodeIdB)"
      ],
      "description": "Returns true if a link conducts power"
   },
   "IsLinkRepairing": {
      "documentation": [
         "bool IsLinkRepairing(int nodeIdA, int nodeIdB)",
         "local result = IsLinkRepairing(nodeIdA, nodeIdB)"
      ],
      "description": "Returns true of the given link is currently repairing"
   },
   "IsNodeDeleting": {
      "documentation": [
         "bool IsNodeDeleting(int nodeId)",
         "local result = IsNodeDeleting(nodeId)"
      ],
      "description": "Returns true if all links of this node are in the scraping state"
   },
   "IsNodeLinkedTo": {
      "documentation": [
         "bool IsNodeLinkedTo(int nodeA, int nodeB)",
         "local result = IsNodeLinkedTo(nodeA, nodeB)"
      ],
      "description": "Returns true if the two nodes are connected via a non-segmented strut"
   },
   "IsNonFoundation": {
      "documentation": [
         "bool IsNonFoundation(int nodeId)",
         "local result = IsNonFoundation(nodeId)"
      ],
      "description": "Returns true for isolated nodes of some materials (e.g. cable)"
   },
   "IsPortal": {
      "documentation": [
         "bool IsPortal(int nodeIdA, int nodeIdB)",
         "local isPortal = IsPortal(nodeIdA, nodeIdB)"
      ],
      "description": "Query whether a strut connecting two nodes is a portal\nBeing connected and active has no bearing on the result\nreturns: true if the strut exists and its material is a portal\nSee also: GetPortalDestinationA, GetPortalDestinationB"
   },
   "LoadStructureFile": {
      "documentation": [
         "void LoadStructureFile(const char* filename, bool clearSim, bool structurePaintedCallback)",
         "LoadStructureFile(\"maps/Vanilla/Vanilla.spr\", false, true)"
      ],
      "description": "Loads a .spr file into the battle\nfilename: the file to load, with path relative to the data directory \nclearSim: destroys the current contents of the world \nstructurePaintedCallback: when true OnStructurePainted is called to allow discovery \nSee also: OnStructurePainted, DestroyStructure"
   },
   "MaterialIsSegmented": {
      "documentation": [
         "bool MaterialIsSegmented(const char* saveName)",
         "local result = MaterialIsSegmented(saveName)"
      ],
      "description": "Returns true if the given material is of a rope type"
   },
   "NodeCount": {
      "documentation": [
         "int NodeCount(int sideId)",
         "local count = NodeCount(sideId)"
      ],
      "description": "Query the total nodes belonging to a side\nsideId: 0, 1 or 2 \nreturns: the number of structure joints belonging to the team\nSee also: GetNodeId"
   },
   "NodeExists": {
      "documentation": [
         "bool NodeExists(unsigned int nodeId)",
         "local result = NodeExists(nodeId)"
      ],
      "description": "Returns true if the given node is valid"
   },
   "NodeLinkCount": {
      "documentation": [
         "int NodeLinkCount(int nodeId)",
         "local result = NodeLinkCount(nodeId)"
      ],
      "description": "Returns the number of struts attached to the given node\nSee also: NodeLinkedNodeId"
   },
   "NodeLinkedNodeId": {
      "documentation": [
         "int NodeLinkedNodeId(int nodeId, int linkIndex)",
         "local result = NodeLinkedNodeId(nodeId, linkIndex)"
      ],
      "description": "Returns the nodeId at the other end of the strut of the given index\nSee also: NodeLinkCount"
   },
   "NodeNonSegmentedLinkCount": {
      "documentation": [
         "int NodeNonSegmentedLinkCount(int nodeId)",
         "local result = NodeNonSegmentedLinkCount(nodeId)"
      ],
      "description": "Returns the number of struts attached to the node which aren't rope type materials"
   },
   "NodePosition": {
      "documentation": [
         "Vector3D NodePosition(int nodeId)",
         "local result = NodePosition(nodeId)"
      ],
      "description": "Query the position of a node\nnodeId: the node to inspect \nSee also: NodeVelocity"
   },
   "NodeSelectable": {
      "documentation": [
         "bool NodeSelectable(int nodeId)",
         "local result = NodeSelectable(nodeId)"
      ],
      "description": "See if a node can be selected by a player\nThe middle nodes of a segmented material (rope) can't be selected"
   },
   "NodeStructureId": {
      "documentation": [
         "int NodeStructureId(int nodeId)",
         "local result = NodeStructureId(nodeId)"
      ],
      "description": "Returns the structureId of the given node"
   },
   "NodeStructureIndex": {
      "documentation": [
         "int NodeStructureIndex(int nodeId)",
         "local result = NodeStructureIndex(nodeId)"
      ],
      "description": "Returns the index of this node within its structure\nSee also: StructureNodeAtIndex"
   },
   "NodeTeam": {
      "documentation": [
         "int NodeTeam(int nodeId)",
         "local teamId = NodeTeam(nodeId)"
      ],
      "description": "Query the team id of a node\nreturns: TEAM_ANY (-1) if the node doesn't exist\nSee also: GetNodeId"
   },
   "NodeVelocity": {
      "documentation": [
         "Vector3D NodeVelocity(int nodeId)",
         "local result = NodeVelocity(nodeId)"
      ],
      "description": "Query the velocity of a node\nSee also: NodePosition"
   },
   "OpenDoor": {
      "documentation": [
         "void OpenDoor(int nodeIdA, int nodeIdB, bool open)",
         "OpenDoor(nodeIdA, nodeIdB, open)"
      ],
      "description": "Opens or closes the specified door\nSame functionality as SetDoorState but a simpler boolean interface and instant is set to false\nSee also: SetDoorState, OpenWeaponDoors, CloseWeaponDoors"
   },
   "OpenWeaponDoors": {
      "documentation": [
         "int OpenWeaponDoors(int id)",
         "local result = OpenWeaponDoors(id)"
      ],
      "description": "Attempts to open the doors in front of the given weapon\nWeapon must be aimed prior for this to be deterministic\nreturns the SP_ codes to indicate what happened\nSee also: CloseWeaponDoors, OpenDoor, SetDoorState"
   },
   "RepairCancelsOnDamage": {
      "documentation": [
         "void RepairCancelsOnDamage(bool enable)",
         "RepairCancelsOnDamage(enable)"
      ],
      "description": "Sets the global property of stopping repair if a strut is damaged"
   },
   "RepairLink": {
      "documentation": [
         "void RepairLink(int nodeIdA, int nodeIdB)",
         "RepairLink(nodeIdA, nodeIdB)"
      ],
      "description": "Starts repairing the given strut"
   },
   "SetDoorState": {
      "documentation": [
         "void SetDoorState(int nodeIdA, int nodeIdB, int newState, bool instant)",
         "SetDoorState(nodeIdA, nodeIdB, newState, instant)"
      ],
      "description": "Allows doors to be controlled.\nnewState can be DS_CLOSED, DS_OPENING, DS_OPEN, or DS_CLOSING.\nIf instant is true and newState is DS_CLOSED or DS_OPEN then\nthe door is forced closed or open immediately.\nSee also: OpenDoor"
   },
   "SetMaterialToCreate": {
      "documentation": [
         "void SetMaterialToCreate(const char* saveName)",
         "SetMaterialToCreate(saveName)"
      ],
      "description": "Sets which material the player has selected"
   },
   "SetStructureConnectable": {
      "documentation": [
         "void SetStructureConnectable(int nodeId, bool connectable)",
         "SetStructureConnectable(nodeId, connectable)"
      ],
      "description": "Allows or blocks connectivity to the structure of the given node\nUsed internally to prevent players connecting to blast doors"
   },
   "SetStructureRepulsive": {
      "documentation": [
         "void SetStructureRepulsive(int nodeId, bool repulsive)",
         "SetStructureRepulsive(nodeId, repulsive)"
      ],
      "description": "Allows or blocks construction near the structure of the given node\nUsed internally to prevent players building near or through blast doors"
   },
   "SnapToNode": {
      "documentation": [
         "int SnapToNode(const Vector3D& pos, int teamId, float maxDist)",
         "local nodeId = SnapToNode(pos, teamId, maxDist)"
      ],
      "description": "Find the closest node within maxDist for a team\nreturns: -1 if none found\nSee also: GetClosestFoundationNodeId"
   },
   "StructureNodeAtIndex": {
      "documentation": [
         "int StructureNodeAtIndex(int structureId, int index)",
         "local result = StructureNodeAtIndex(structureId, index)"
      ],
      "description": "Returns the node Id at an index within a structure\nSee also: NodeStructureIndex, NodeStructureId"
   },
   "SwitchPortal": {
      "documentation": [
         "int SwitchPortal(int teamId, int nodeIdA, int nodeIdB)",
         "local result = SwitchPortal(teamId, nodeIdA, nodeIdB)"
      ],
      "description": "Reverses the direction of the specified portal\nteamId: the teamId the nodes should be owned by \nnodeIdA: the first node of the portal \nnodeIdB: the second node of the portal \nreturns: CP_SUCCESS or CP_INVALIDNODES"
   },
   "GetClientTeamId": {
      "documentation": [
         "int GetClientTeamId(int index)",
         "local result = GetClientTeamId(index)"
      ],
      "description": "Queries the teamId of the client at a given index\nreturns TEAM_NEUTRAL if a player doesn't exist at that index\nSee also: GetLocalTeamId, GetLocalClientIndex"
   },
   "GetLocalClientIndex": {
      "documentation": [
         "int GetLocalClientIndex()",
         "local result = GetLocalClientIndex()"
      ],
      "description": "Queries the client index of the local game instance\nA value of 0 indicates the host\nSee also: GetLocalTeamId, GetClientTeamId"
   },
   "GetLocalTeamId": {
      "documentation": [
         "int GetLocalTeamId()",
         "local result = GetLocalTeamId()"
      ],
      "description": "Queries the teamId of the local game instance\nyou should only affect things like user interface, enabled items, etc.\nUse SendScriptEvent to execute code synchronously across all instances"
   },
   "GetTeamCount": {
      "documentation": [
         "int GetTeamCount()",
         "local result = GetTeamCount()"
      ],
      "description": "Used to discover the actual number teams in play\nUse GetTeam to get the teamId for each index"
   },
   "GetTeamId": {
      "documentation": [
         "int GetTeamId(int index)",
         "local result = GetTeamId(index)"
      ],
      "description": "In co-op battles this will return 0, 1 and 2\nIn team death match this will return 0, 1, 2 and 101, 201, etc. for teams within a side\nUse teamId%MAX_SIDES to get the side of these (1 or 2)"
   },
   "GetTeamResources": {
      "documentation": [
         "::Value GetTeamResources(int teamId)",
         "local result = GetTeamResources(teamId)"
      ],
      "description": "Query the current resource balance of the given team"
   },
   "IsHumanOnSide": {
      "documentation": [
         "bool IsHumanOnSide(int sideId)",
         "local result = IsHumanOnSide(sideId)"
      ],
      "description": "Query whether a human player is currently on a side"
   },
   "SetTeamFlag": {
      "documentation": [
         "void SetTeamFlag(int teamId, int flag, bool enable)",
         "SetTeamFlag(teamId, flag, enable)"
      ],
      "description": "Set a team bit flag (e.g. no construct effects for devices, links and nodes)\nflags: One of the TEAMFLAG_* values from forts.lua (e.g. TEAMFLAG_SILENT) "
   },
   "AddBlockVertex": {
      "documentation": [
         "int AddBlockVertex(int blockIndex, const Vector3D& pos, int edgeOverride)",
         "local result = AddBlockVertex(blockIndex, pos, edgeOverride)"
      ],
      "description": "Add a vertex to an existing ground block\nUse UpdateGroundTriangles when finished making changes\nblockIndex: the index of the block (valid range: 0 to block count - 1) \nSee also: GetBlockCount, UpdateGroundTriangles"
   },
   "ClearBlockSelection": {
      "documentation": [
         "void ClearBlockSelection()",
         "ClearBlockSelection()"
      ],
      "description": "Remove all blocks from the current selection\nSee also: SelectBlock"
   },
   "CreateBlock": {
      "documentation": [
         "int CreateBlock()",
         "local blockIndex = CreateBlock()"
      ],
      "description": "Create a new ground block\nThe owner of the block is set to the local team, use SetBlockOwner to change it\nreturns: the index of the block that was created (not constant when blocks are deleted)\nSee also: SetBlockOwner, SetBlockTexture, AddBlockVertex"
   },
   "EnableTerrainBlock": {
      "documentation": [
         "void EnableTerrainBlock(const char* name, bool enable)",
         "EnableTerrainBlock(name, enable)"
      ],
      "description": "Show or hide any terrain blocks with a specific name"
   },
   "FlipBlockNormals": {
      "documentation": [
         "void FlipBlockNormals(int blockIndex)",
         "FlipBlockNormals(blockIndex)"
      ],
      "description": "Invert the normals (surface up vectors) of a terrain block\nblockIndex: the index of the block (valid range: 0 to block count - 1) \nSee also: GetBlockCount"
   },
   "GetBlockCount": {
      "documentation": [
         "int GetBlockCount()",
         "local result = GetBlockCount()"
      ],
      "description": "Query the total number of blocks in the world"
   },
   "GetBlockOwner": {
      "documentation": [
         "int GetBlockOwner(int blockIndex)",
         "local result = GetBlockOwner(blockIndex)"
      ],
      "description": "Query the owner of a terrain block\nSee also: SetBlockOwner"
   },
   "GetBlockSelection": {
      "documentation": [
         "int GetBlockSelection(int index)",
         "local blockIndex = GetBlockSelection(index)"
      ],
      "description": "Gets the block index within the current selection\nIntended for use within terraform scripts only\nreturns: -1 if index is invalid\nSee also: GetBlockSelectionCount"
   },
   "GetBlockSelectionCount": {
      "documentation": [
         "int GetBlockSelectionCount()",
         "local result = GetBlockSelectionCount()"
      ],
      "description": "Gets the number of blocks selected\nIntended for use within terraform scripts only\nSee also: GetBlockSelection"
   },
   "GetBlockVertexCount": {
      "documentation": [
         "int GetBlockVertexCount(int blockIndex)",
         "local result = GetBlockVertexCount(blockIndex)"
      ],
      "description": "Query the number of vertices in a block\nblockIndex: the index of the block (valid range: 0 to block count - 1) \nSee also: GetBlockCount"
   },
   "GetBlockVertexPos": {
      "documentation": [
         "Vector3D GetBlockVertexPos(int blockIndex, int vertexIndex)",
         "local result = GetBlockVertexPos(blockIndex, vertexIndex)"
      ],
      "description": "Query the position of a terrain block vertex\nblockIndex: the index of the block (valid range: 0 to block count - 1) \nSee also: GetBlockCount, GetBlockVertexCount"
   },
   "GetPosGroundBlockIndex": {
      "documentation": [
         "int GetPosGroundBlockIndex(const Vector3D& pos)",
         "local blockIndex = GetPosGroundBlockIndex(pos)"
      ],
      "description": "Query the index of the block that snaps to the given position\nreturns: -1 if no block within snap distance"
   },
   "GetSurfaceIndex": {
      "documentation": [
         "int GetSurfaceIndex(const char* surfaceName)",
         "local surfaceIndex = GetSurfaceIndex(surfaceName)"
      ],
      "description": "Find the surface index of a surface name\nreturns: -1 if not found\nSee also: SetBlockSurface"
   },
   "GetSurfaceSaveName": {
      "documentation": [
         "const char* GetSurfaceSaveName(int surfaceType)",
         "local surfaceName = GetSurfaceSaveName(surfaceType)"
      ],
      "description": "Query the name of a surface\nsurfaceType: the index of the surface \nreturns: empty string if surfaceType is invalid"
   },
   "GetTerrainBlockIndex": {
      "documentation": [
         "int GetTerrainBlockIndex(const char* name)",
         "local blockIndex = GetTerrainBlockIndex(name)"
      ],
      "description": "Find the index of the first terrain block with a specific name\nreturns: -1 if not found"
   },
   "IsPointInBlock": {
      "documentation": [
         "bool IsPointInBlock(const Vector3D& pos, int blockIndex)",
         "local result = IsPointInBlock(pos, blockIndex)"
      ],
      "description": "Query whether a point in space is inside a specific terrain block\npos: the position of the point \nSee also: GetBlockCount"
   },
   "IsPointOnGround": {
      "documentation": [
         "bool IsPointOnGround(const Vector3D& pos, int teamId)",
         "local result = IsPointOnGround(pos, teamId)"
      ],
      "description": "Query whether a point in space is on a terrain block surface\npos: the position of the point \nteamId: not used \nSee also: IsPointInBlock"
   },
   "IsTeamConnectedToGroundBlock": {
      "documentation": [
         "bool IsTeamConnectedToGroundBlock(int teamId, int blockIndex)",
         "local result = IsTeamConnectedToGroundBlock(teamId, blockIndex)"
      ],
      "description": "Queries whether the given team has a node touching a terrain block\nteamId: the team to check connection for \nblockIndex: the index of the block (valid range: 0 to block count - 1) \nSee also: GetBlockCount"
   },
   "MirrorHorizontal": {
      "documentation": [
         "void MirrorHorizontal(int blockIndex, const Vector3D& pivot)",
         "MirrorHorizontal(blockIndex, pivot)"
      ],
      "description": "Flip a terrain block sideways about a point in space\nblockIndex: the index of the block (valid range: 0 to block count - 1) \nSee also: GetBlockCount"
   },
   "MirrorVertical": {
      "documentation": [
         "void MirrorVertical(int blockIndex, const Vector3D& pivot)",
         "MirrorVertical(blockIndex, pivot)"
      ],
      "description": "Flip a terrain block up and down about a point in space\nblockIndex: the index of the block (valid range: 0 to block count - 1) \nSee also: GetBlockCount"
   },
   "SelectBlock": {
      "documentation": [
         "void SelectBlock(int blockIndex)",
         "SelectBlock(blockIndex)"
      ],
      "description": "Add a terrain block to the current selection\nblockIndex: the index of the block (valid range: 0 to block count - 1) \nSee also: GetBlockCount, ClearBlockSelection"
   },
   "SetBlockFlags": {
      "documentation": [
         "void SetBlockFlags(int blockIndex, int flagsToSet, bool value)",
         "SetBlockFlags(blockIndex, flagsToSet, value)"
      ],
      "description": "Change a subset of flags on a block\nblockIndex: the index of the block (valid range: 0 to block count - 1) \nflagsToSet: a combination of BLOCKFLAG_* values (see scripts/shapes.lua) \nvalue: true to enable the specified flag \nSee also: GetBlockCount"
   },
   "SetBlockOwner": {
      "documentation": [
         "void SetBlockOwner(int blockIndex, Owner teamId)",
         "SetBlockOwner(blockIndex, teamId)"
      ],
      "description": "Change the owner of a terrain block\nSee also: CreateBlock, SetBlockTexture"
   },
   "SetBlockSurface": {
      "documentation": [
         "void SetBlockSurface(int blockIndex, int surfaceIndex)",
         "SetBlockSurface(blockIndex, surfaceIndex)"
      ],
      "description": "Change the base edge of a ground block\nThis can be overridden for each edge\nblockIndex: the index of the block (valid range: 0 to block count - 1) \nSee also: SetBlockTexture"
   },
   "SetBlockTexture": {
      "documentation": [
         "void SetBlockTexture(int blockIndex, const char* filename)",
         "SetBlockTexture(blockIndex, filename)"
      ],
      "description": "Change the texture of a ground block\nblockIndex: the index of the block (valid range: 0 to block count - 1) \nSee also: GetBlockCount, GetEnvironmentPath"
   },
   "SetBlockVertexPos": {
      "documentation": [
         "void SetBlockVertexPos(int blockIndex, int vertexIndex, const Vector3D& pos)",
         "SetBlockVertexPos(blockIndex, vertexIndex, pos)"
      ],
      "description": "Change the position of a vertex in a terrain block\nUse UpdateGroundTriangles when finished making changes\nblockIndex: the index of the block (valid range: 0 to block count - 1) \nSee also: GetBlockCount, GetBlockVertexCount, UpdateGroundTriangles"
   },
   "UpdateGroundTriangles": {
      "documentation": [
         "void UpdateGroundTriangles()",
         "UpdateGroundTriangles()"
      ],
      "description": "Recalculates the terrain triangles and open edges\nUse this after making changes to a block's nodes\nSee also: AddBlockVertex, SetBlockVertexPos"
   },
   "EnableLobbyAlerts": {
      "documentation": [
         "void EnableLobbyAlerts(bool enable)",
         "EnableLobbyAlerts(enable)"
      ],
      "description": "Allows suppression of lobby alerts"
   },
   "EnableTip": {
      "documentation": [
         "void EnableTip(const char* name, bool enable)",
         "EnableTip(\"TipBattery\", false)"
      ],
      "description": "Enables or disables a specific tip by name\nname: tip names can be found in mods/language-English/db/strings.lua "
   },
   "EnableTipDismissal": {
      "documentation": [
         "void EnableTipDismissal(bool enable)",
         "EnableTipDismissal(enable)"
      ],
      "description": "Causes tips to ignore or accept user dismissal\nSee also: EnableTip, HideTip"
   },
   "HideTip": {
      "documentation": [
         "void HideTip()",
         "HideTip()"
      ],
      "description": "Makes the currently shown tip invisible, if any\nSee also: ShowTip, ShowTipChecked"
   },
   "IsTipVisible": {
      "documentation": [
         "bool IsTipVisible()",
         "local tipIsVisible = IsTipVisible()"
      ],
      "description": "Query if a tip is currently visible\nreturns: true if a tip is being shown"
   },
   "ShowTip": {
      "documentation": [
         "bool ShowTip(const char* filename, const char* stringId)",
         "local wasShown = ShowTip(filename, stringId)"
      ],
      "description": "Triggers a tip graphic with a specific stringId\nfilename: The path of the graphic to show \nstringId: The string id to use for translation \nreturns: true if the tip was successfully shown\nSee also: ShowTipChecked, HideTip, TipsEnabled"
   },
   "ShowTipChecked": {
      "documentation": [
         "bool ShowTipChecked(const char* filename, const char* stringId, const char* checkboxId, bool forceCloseExisting)",
         "local wasShown = ShowTipChecked(filename, stringId, checkboxId, forceCloseExisting)"
      ],
      "description": "Triggers a tip graphic with a specific stringId, has a checkbox to not show the same tip again\nAvoid using tips if TipsEnabled() returns false\nfilename: the path of the graphic to show \nstringId: the string id to use for translation \ncheckboxId: A unique name to identify this checkbox, to allow permanent disabling \nforceCloseExisting: Force hide/replace any currently displayed tip \nreturns: true if the tip was successfully shown\nSee also: ShowTip, HideTip, TipsEnabled"
   },
   "TipsEnabled": {
      "documentation": [
         "bool TipsEnabled()",
         "local enabled = TipsEnabled()"
      ],
      "description": "Query whether the player has tips enabled in their options\nGenerally this should be tested and respected when using ShowTip\nreturns: true if the player doesn't want tips showing\nSee also: ShowTip, ShowTipChecked"
   },
   "AddButtonControl": {
      "documentation": [
         "void AddButtonControl(const char* parent, const char* name, const char* sprite, int anchor, const Vector3D& size, const Vector3D& pos, const char* style)",
         "AddButtonControl(parent, name, sprite, anchor, size, pos, style)"
      ],
      "description": "Creates a textured button control\nOnControlActivated will be called when the button is pressed\nparent: the parent of the new control. Empty string means the HUD root. \nname: the name of new control \nsprite: the initial texture or sprite of the control \nanchor: one of the ANCHOR_* values defined in forts.lua (e.g. ANCHOR_TOP_LEFT) \nsize: the size of control as a Vec3 \npos: the position of control relative to its parent \nstyle: one of the styles defined in ui/styles.lua \nSee also: OnControlActivated, AddTextButtonControl, DeleteControl"
   },
   "AddContextButton": {
      "documentation": [
         "void AddContextButton(const char* sprite, const char* name, int row, bool enabled, bool pressed)",
         "AddContextButton(sprite, name, row, enabled, pressed)"
      ],
      "description": "Adds a customised button on the context menu\nWhen the button is pressed the script is notified by a call to OnContextButtonDevice or OnContextButtonStrut"
   },
   "AddGhostDevice": {
      "documentation": [
         "void AddGhostDevice(const char* saveName, int teamId, const Vector3D& pos, int direction)",
         "AddGhostDevice(saveName, teamId, pos, direction)"
      ],
      "description": "Creates a new ghost device/weapon\nUseful for instructing players in a cutscene"
   },
   "AddListItem": {
      "documentation": [
         "void AddListItem(const char* parent, const char* name, const char* text, float minContentsHeight, float maxContentsHeight)",
         "AddListItem(parent, name, text, minContentsHeight, maxContentsHeight)"
      ],
      "description": "Adds a new list item to an existing list box\nparent: the parent list box to add the item to \nname: the name of new list item \ntext: the display text for the item \nminContentsHeight: if > 0, will resize listbox height to match contents, limiting min listbox height to this value \nmaxContentsHeight: if > 0, will resize listbox height to match contents,limiting max listbox height to this value \nSee also: ClearListItems"
   },
   "AddSpriteControl": {
      "documentation": [
         "void AddSpriteControl(const char* parent, const char* name, const char* sprite, int anchor, const Vector3D& size, const Vector3D& pos, bool worldRelative)",
         "AddSpriteControl(parent, name, sprite, anchor, size, pos, worldRelative)"
      ],
      "description": "Creates a new texture or animated texture control\nparent: the parent of the new control. Empty string means the HUD root. \nname: the name of new control \nsprite: the initial texture or sprite of the control \nanchor: one of the ANCHOR_* values defined in forts.lua (e.g. ANCHOR_TOP_LEFT) \nsize: the size of control \npos: the position of control relative to its parent \nworldRelative: true means the position is relative to world objects \nSee also: DeleteControl"
   },
   "AddTextButtonControl": {
      "documentation": [
         "void AddTextButtonControl(const char* parent, const char* name, const char* text, int anchor, const Vector3D& pos, bool worldRelative, const char* style)",
         "AddTextButtonControl(parent, name, text, anchor, pos, worldRelative, style)"
      ],
      "description": "Creates a new text button control\nOnControlActivated will be called when the button is pressed\nparent: the parent of the new control. Empty string means the HUD root. \nname: the name of new control \ntext: the initial content of the text button \nanchor: one of the ANCHOR_* values defined in forts.lua (e.g. ANCHOR_TOP_LEFT) \npos: the position of control relative to its parent \nworldRelative: true means the text size is constant relative to world objects \nstyle: one of the styles defined in ui/styles.lua \nSee also: OnControlActivated, AddButtonControl, AddTextControl, DeleteControl"
   },
   "AddTextControl": {
      "documentation": [
         "void AddTextControl(const char* parent, const char* name, const char* text, int anchor, const Vector3D& pos, bool worldRelative, const char* style)",
         "AddTextControl(parent, name, text, anchor, pos, worldRelative, style)"
      ],
      "description": "Creates a new text control\nparent: the parent of the new control. Empty string means the HUD root. \nname: the name of new control \ntext: the initial content of the text button \nanchor: one of the ANCHOR_* values defined in forts.lua (e.g. ANCHOR_TOP_LEFT) \npos: the position of control relative to its parent \nworldRelative: true means the text size is constant relative to world objects \nstyle: one of the styles defined in ui/styles.lua \nSee also: AddTextButtonControl, AddButtonControl, AddSpriteControl, DeleteControl"
   },
   "CenterControl": {
      "documentation": [
         "void CenterControl(const char* parent, const char* name, bool centerHoriz, bool centerVert)",
         "CenterControl(parent, name, centerHoriz, centerVert)"
      ],
      "description": "Centers a control horizontally and vertically relative to its parent\nThe screen is used if there's no parent\nSee also: SetControlFrame"
   },
   "ClearGhostDevices": {
      "documentation": [
         "void ClearGhostDevices()",
         "ClearGhostDevices()"
      ],
      "description": "Destroys all ghost devices"
   },
   "ClearListItems": {
      "documentation": [
         "void ClearListItems(const char* parent, const char* name, float minContentsHeight)",
         "ClearListItems(parent, name, minContentsHeight)"
      ],
      "description": "Clears all items for a list box\nparent: the of the list box \nname: the name of list box to clear \nminContentsHeight: if > 0, will resize listbox height to this value \nSee also: AddListItem"
   },
   "DeleteControl": {
      "documentation": [
         "void DeleteControl(const char* parent, const char* name)",
         "DeleteControl(parent, name)"
      ],
      "description": "Destroys a control\nSee also: ShowControl, SetControlFrame"
   },
   "EnableExpandedHUD": {
      "documentation": [
         "void EnableExpandedHUD(bool enable)",
         "EnableExpandedHUD(enable)"
      ],
      "description": "Enables or disables the full screen HUD"
   },
   "EnableGrid": {
      "documentation": [
         "void EnableGrid(bool enable)",
         "EnableGrid(enable)"
      ],
      "description": "Enables or disables the grid used by the player to snap nodes and ground devices"
   },
   "EnablePauseMenu": {
      "documentation": [
         "void EnablePauseMenu(bool enable)",
         "EnablePauseMenu(enable)"
      ],
      "description": "Enables or disables the pause menu\nIf the pause menu is active when disabled the pause menu will be hidden"
   },
   "EnablePauseMenuItem": {
      "documentation": [
         "void EnablePauseMenuItem(const char* name, bool enable)",
         "EnablePauseMenuItem(name, enable)"
      ],
      "description": "Can prevent the addition of an option to the pause menu\nname: values can be \"Revert\", \"Resume\", \"InstantReplay\", \"Next\" "
   },
   "EndMovie": {
      "documentation": [
         "void EndMovie(const char* parent, const char* name)",
         "EndMovie(parent, name)"
      ],
      "description": "Stops and cleans up movie playback on a sprite or button control"
   },
   "EvaluateLayoutScript": {
      "documentation": [
         "void EvaluateLayoutScript(const char* parent, const char* name, bool recursive)",
         "EvaluateLayoutScript(parent, name, recursive)"
      ],
      "description": "Force a UI control to re-evaluate its layout script\nrecursive: true means recursively evaluate child controls "
   },
   "GetChildCount": {
      "documentation": [
         "int GetChildCount(const char* parent)",
         "local count = GetChildCount(parent)"
      ],
      "description": "Query the number of child controls of a control\nreturns: how many children the control has\nSee also: SetControlFrame"
   },
   "GetChildName": {
      "documentation": [
         "const char* GetChildName(const char* parent, int index)",
         "local childName = GetChildName(parent, index)"
      ],
      "description": "Query the name of a child control\nindex: the zero-based index of the child. Use GetChildCount to get the upper limit. \nreturns: the name of the child. Empty string if index is invalid.\nSee also: SetControlFrame"
   },
   "GetControlAbsolutePos": {
      "documentation": [
         "Vector3D GetControlAbsolutePos(const char* parent, const char* name)",
         "local result = GetControlAbsolutePos(parent, name)"
      ],
      "description": "Query the position of a control relative to the root control\nSee also: SetControlFrame"
   },
   "GetControlFrame": {
      "documentation": [
         "int GetControlFrame()",
         "local frame = GetControlFrame()"
      ],
      "description": "Indicates whether UI functions work in screen space or world space\nreturns: FRAME_SCREEN (0) or FRAME_WORLD (1)\nSee also: SetControlFrame"
   },
   "GetControlRelativePos": {
      "documentation": [
         "Vector3D GetControlRelativePos(const char* parent, const char* name)",
         "local result = GetControlRelativePos(parent, name)"
      ],
      "description": "Query the position of a control relative to its parent\nSee also: SetControlFrame"
   },
   "GetControlSize": {
      "documentation": [
         "Vector3D GetControlSize(const char* parent, const char* name)",
         "local size = GetControlSize(parent, name)"
      ],
      "description": "Queries the width and height of a control\nreturns: a Vec3 containing the width and height\nSee also: SetControlFrame"
   },
   "GetControlStyle": {
      "documentation": [
         "const char* GetControlStyle(const char* parent, const char* name)",
         "local style = GetControlStyle(parent, name)"
      ],
      "description": "Query the style of a control\nreturns: the style name of the control. Empty if not found.\nSee also: SetControlFrame"
   },
   "GetMovieProgress": {
      "documentation": [
         "float GetMovieProgress(const char* parent, const char* name)",
         "local progress = GetMovieProgress(parent, name)"
      ],
      "description": "Queries how much of the movie has completed playback in relative terms\nreturns: a number between 0 and 1 representing progress"
   },
   "GetMovieTime": {
      "documentation": [
         "float GetMovieTime(const char* parent, const char* name)",
         "local progress = GetMovieTime(parent, name)"
      ],
      "description": "Queries how much of the movie has completed playback in seconds from the start\nreturns: the time in seconds since the beginning of the movie"
   },
   "LetterboxVisible": {
      "documentation": [
         "bool LetterboxVisible()",
         "local result = LetterboxVisible()"
      ],
      "description": "Queries whether the letterbox is visible\nAffected by ShowLetterbox"
   },
   "LoadControl": {
      "documentation": [
         "void LoadControl(const char* filename, const char* parent)",
         "LoadControl(filename, parent)"
      ],
      "description": "Loads a control tree from a file and adds it to the specified parent\nFor OnControlActivated to work for Button and TextButton controls, use SetButtonCallback for each one.\nSee also: SetControlFrame, SetButtonCallback, OnControlActivated"
   },
   "PauseMovie": {
      "documentation": [
         "void PauseMovie(const char* parent, const char* name, bool pause)",
         "PauseMovie(parent, name, pause)"
      ],
      "description": "Pauses or resumes movie playback on a sprite or button control"
   },
   "PlayMovie": {
      "documentation": [
         "void PlayMovie(const char* parent, const char* name, const char* filename)",
         "PlayMovie(parent, name, filename)"
      ],
      "description": "Starts movie playback on a sprite or button control"
   },
   "RotateSpriteControl": {
      "documentation": [
         "void RotateSpriteControl(const char* parent, const char* name, int timesClockwise)",
         "RotateSpriteControl(parent, name, timesClockwise)"
      ],
      "description": "Turns the rendering of the texture by a number of 90 degree rotations\nSee also: SetControlFrame"
   },
   "SetButtonCallback": {
      "documentation": [
         "void SetButtonCallback(const char* parent, const char* name, int id)",
         "SetButtonCallback(parent, name, id)"
      ],
      "description": "Sets the numerical activation id associated with a control\nSee also: SetControlFrame, LoadControl"
   },
   "SetControlAbsolutePos": {
      "documentation": [
         "void SetControlAbsolutePos(const char* parent, const char* name, const Vector3D& pos)",
         "SetControlAbsolutePos(parent, name, pos)"
      ],
      "description": "Sets the position of a control relative to its root control\nSee also: SetControlFrame"
   },
   "SetControlColour": {
      "documentation": [
         "void SetControlColour(const char* parent, const char* name, const Colour& col)",
         "SetControlColour(parent, name, col)"
      ],
      "description": "Changes the colour of a control\nSee also: SetControlFrame"
   },
   "SetControlFrame": {
      "documentation": [
         "void SetControlFrame(int frame)",
         "SetControlFrame(frame)"
      ],
      "description": "Determines whether UI functions work in screen space or world space\nThis value is persistent for the calling script, until changed by this function\nEquivalent to the worldRelative parameter passed to the Add* UI functions\nframe: FRAME_SCREEN (0) or FRAME_WORLD (1) "
   },
   "SetControlLayoutH": {
      "documentation": [
         "void SetControlLayoutH(const char* parent, const char* name, const char* script)",
         "SetControlLayoutH(parent, name, script)"
      ],
      "description": "Sets the dynamic layout script for the height of a control\nSee also: SetControlFrame"
   },
   "SetControlLayoutW": {
      "documentation": [
         "void SetControlLayoutW(const char* parent, const char* name, const char* script)",
         "SetControlLayoutW(parent, name, script)"
      ],
      "description": "Sets the dynamic layout script for the width of a control\nSee also: SetControlFrame"
   },
   "SetControlLayoutX": {
      "documentation": [
         "void SetControlLayoutX(const char* parent, const char* name, const char* script)",
         "SetControlLayoutX(parent, name, script)"
      ],
      "description": "Sets the dynamic layout script for the horizontal position of a control\nSee also: SetControlFrame"
   },
   "SetControlLayoutY": {
      "documentation": [
         "void SetControlLayoutY(const char* parent, const char* name, const char* script)",
         "SetControlLayoutY(parent, name, script)"
      ],
      "description": "Sets the dynamic layout script for the vertical position of a control\nSee also: SetControlFrame"
   },
   "SetControlRelativePos": {
      "documentation": [
         "void SetControlRelativePos(const char* parent, const char* name, const Vector3D& pos)",
         "SetControlRelativePos(parent, name, pos)"
      ],
      "description": "Set the position of a control relative to its parent\nSee also: SetControlFrame"
   },
   "SetControlSize": {
      "documentation": [
         "void SetControlSize(const char* parent, const char* name, const Vector3D& size)",
         "SetControlSize(parent, name, size)"
      ],
      "description": "Sets the width and height of a control\nsize: a Vec3 with x set to the width and y set to the height \nSee also: SetControlFrame"
   },
   "SetControlSprite": {
      "documentation": [
         "void SetControlSprite(const char* name, const char* sprite)",
         "SetControlSprite(name, sprite)"
      ],
      "description": "Sets the texture or animate texture of a sprite or button control\nSee also: SetControlSpriteByParent, SetControlFrame"
   },
   "SetControlSpriteByParent": {
      "documentation": [
         "void SetControlSpriteByParent(const char* parent, const char* name, const char* sprite)",
         "SetControlSpriteByParent(parent, name, sprite)"
      ],
      "description": "Sets the texture or animate texture of a sprite or button control\nDiffers from SetControlSprite by using the parent parameter to disambiguate the control\nSee also: SetControlSprite"
   },
   "SetControlStyle": {
      "documentation": [
         "void SetControlStyle(const char* parent, const char* name, const char* style)",
         "SetControlStyle(parent, name, \"Heading\")"
      ],
      "description": "Sets the style of a control, which affects font size, outline, shadows, colour, etc.\nstyle: styles are defined in ui/styles.lua \nSee also: SetControlFrame"
   },
   "SetControlText": {
      "documentation": [
         "void SetControlText(const char* parent, const char* name, const char* text)",
         "SetControlText(\"\", \"MyMessage\", \"Hello, world\")"
      ],
      "description": "Changes the content of a text or text button control\nTriggers the re-evaluation of dynamic layout under the parent\nPrefix the text parameter with '$' to specify a string id\nparent: an empty string means the HUD root \nSee also: SetControlFrame"
   },
   "SetControlTextW": {
      "documentation": [
         "void SetControlTextW(const char* parent, const char* name, const lua_WChar* text)",
         "SetControlTextW(\"HUD\", \"MyMessage\", L\"Hello, world\")"
      ],
      "description": "Changes the content of a text or text button control\nTriggers the re-evaluation of dynamic layout under the parent\nparent: an empty string means the HUD root \nSee also: SetControlFrame"
   },
   "SetCursorColour": {
      "documentation": [
         "void SetCursorColour(float r, float g, float b, float a)",
         "SetCursorColour(r, g, b, a)"
      ],
      "description": "Changes the colour of the cursor"
   },
   "SetMouseCursor": {
      "documentation": [
         "void SetMouseCursor(int mode, bool force)",
         "SetMouseCursor(mode, force)"
      ],
      "description": "Changes the appearance of the cursor\nmode: one of the MOUSE_* values from constants.lua \nforce: when true the mode will be sticky; ordinary cursor control won't work "
   },
   "SetSpriteAdditive": {
      "documentation": [
         "void SetSpriteAdditive(const char* parent, const char* name, bool enable)",
         "SetSpriteAdditive(parent, name, enable)"
      ],
      "description": "Controls additive rendering of a sprite or button control\nSee also: SetControlFrame"
   },
   "SetSpriteState": {
      "documentation": [
         "void SetSpriteState(const char* parent, const char* name, const char* state)",
         "SetSpriteState(parent, name, state)"
      ],
      "description": "Sets the state of an animated texture on a sprite or button control\nSee also: SetControlSprite, SetControlSpriteByParent, SetControlFrame"
   },
   "SetWordWrap": {
      "documentation": [
         "void SetWordWrap(const char* parent, const char* name, bool wrap)",
         "SetWordWrap(parent, name, wrap)"
      ],
      "description": "Sets the word wrap of a text control within a sprite control parent\nSee also: SetControlFrame"
   },
   "ShowControl": {
      "documentation": [
         "void ShowControl(const char* parent, const char* name, bool show)",
         "ShowControl(parent, name, show)"
      ],
      "description": "Makes a control visible or not\nSee also: DeleteControl, SetControlFrame"
   },
   "ShowLetterbox": {
      "documentation": [
         "void ShowLetterbox(bool show)",
         "ShowLetterbox(show)"
      ],
      "description": "Turns on or off the letterbox used in cutscenes"
   },
   "ShowWorld": {
      "documentation": [
         "void ShowWorld(bool show)",
         "ShowWorld(show)"
      ],
      "description": "Turns rendering of the world on or off"
   },
   "CancelCameraMove": {
      "documentation": [
         "void CancelCameraMove()",
         "CancelCameraMove()"
      ],
      "description": "Stops the current camera movement\nSee also: RestoreScreen, RestoreSystemScreen"
   },
   "ClearViewExtents": {
      "documentation": [
         "void ClearViewExtents()",
         "ClearViewExtents()"
      ],
      "description": "Resets the player's view limits to the world extents\nSee also: SetViewExtentsByName, SetViewExtentLeft, SetViewExtentRight"
   },
   "DeleteNamedScreen": {
      "documentation": [
         "void DeleteNamedScreen(const char* name)",
         "DeleteNamedScreen(name)"
      ],
      "description": "Removes a previously created or saved screen\nSee also: SetnamedScreenByZoom, SetnamedScreenByHeight, RestoreScreen"
   },
   "GetCamera": {
      "documentation": [
         "ScreenPosition GetCamera()",
         "local extents = GetCamera()"
      ],
      "description": "Queries the current extents and zoom of the camera\nreturns: extents are returned in a table containing MinX, MaxX, MinY, MaxY and Zoom\nSee also: GetCameraFocus, GetWorldExtents"
   },
   "GetCameraFocus": {
      "documentation": [
         "Vector3D GetCameraFocus()",
         "local result = GetCameraFocus()"
      ],
      "description": "Query the current centre of the screen\nSee also: GetCamera"
   },
   "GetCameraZoom": {
      "documentation": [
         "float GetCameraZoom()",
         "local result = GetCameraZoom()"
      ],
      "description": "Query the current zoom level\nSee also: GetMinZoom"
   },
   "GetMinZoom": {
      "documentation": [
         "float GetMinZoom()",
         "local result = GetMinZoom()"
      ],
      "description": "Query the minimum zoom level\nThis specifies how far the camera can zoom in\nSee also: GetCameraZoom"
   },
   "GetWorldExtents": {
      "documentation": [
         "ScreenPosition GetWorldExtents()",
         "local extents = GetWorldExtents()"
      ],
      "description": "Queries the minimum and maximum x and y of the world\nreturns: extents are returned in a table containing MinX, MaxX, MinY, MaxY and Zoom\nSee also: GetCamera"
   },
   "IsPointVisible": {
      "documentation": [
         "bool IsPointVisible(const Vector3D& worldPos, const char* screenName)",
         "local visible = IsPointVisible(Vec3(400, 150), \"\")"
      ],
      "description": "Query if a world position is visible\nworldPos: the point to test \nscreenName: optional named screen (empty for the current view) \nreturns: true if the point is within the screen"
   },
   "RestoreScreen": {
      "documentation": [
         "void RestoreScreen(const char* name, float duration, float easePeriod, bool allowInterruption)",
         "RestoreScreen(name, duration, easePeriod, allowInterruption)"
      ],
      "description": "Sets the player's view to a named screen position\nname: the name of the screen - these can be set in the map editor using the \\save_screen command \nduration: how long it takes the camera to move there. Can be zero. \neasePeriod: controls how smoothly the camera starts and stops. 0 is jerky, 0.5 is smooth. \nallowInterruption: when true the player can issue other commands to change the camera. \nSee also: CancelCameraMove"
   },
   "RestoreSystemScreen": {
      "documentation": [
         "void RestoreSystemScreen(int index, float duration)",
         "RestoreSystemScreen(index, duration)"
      ],
      "description": "Sets the player's view to one of the standard cameras\nindex: 0 = overview, 1 = team1, 2 = team2 \nduration: how long it takes the camera to move there. Can be zero to be instance. \nSee also: CancelCameraMove, SetSystemScreenFromName"
   },
   "ScreenToWorld": {
      "documentation": [
         "Vector3D ScreenToWorld(const Vector3D& pos)",
         "local result = ScreenToWorld(pos)"
      ],
      "description": "Transform a screen position to world coordinates\nUseful for finding the world position of a mouse coordinate"
   },
   "SetNamedScreenByHeight": {
      "documentation": [
         "void SetNamedScreenByHeight(const char* name, const Vector3D& pos, float height)",
         "SetNamedScreenByHeight(name, pos, height)"
      ],
      "description": "Creates or overwrites a named screen for later use\nname: the name of the screen - same as can be set in the map editor using the \\save_screen command \npos: the center position of the screen \nheight: the viewable vertical size of the screen - clamped to the allowable range \nSee also: SetnamedScreenByZoom, RestoreScreen, DeleteNamedScreen"
   },
   "SetNamedScreenByZoom": {
      "documentation": [
         "void SetNamedScreenByZoom(const char* name, const Vector3D& pos, float zoom)",
         "SetNamedScreenByZoom(name, pos, zoom)"
      ],
      "description": "Creates or overwrites a named screen for later use\nname: the name of the screen - same as can be set in the map editor using the \\save_screen command \npos: the center position of the screen \nzoom: the zoom level of the screen - clamped to the allowable range \nSee also: SetnamedScreenByHeight, RestoreScreen, DeleteNamedScreen"
   },
   "SetSystemScreenFromName": {
      "documentation": [
         "void SetSystemScreenFromName(int index, const char* name)",
         "SetSystemScreenFromName(index, name)"
      ],
      "description": "Assigns a named screen to one of the system screens\nindex: 0 = overview, 1 = team1, 2 = team2 \nSee also: RestoreSystemScreen, SetNamedScreenByZoom, SetNamedScreenByHeight"
   },
   "SetViewExtentLeft": {
      "documentation": [
         "void SetViewExtentLeft(float x)",
         "SetViewExtentLeft(x)"
      ],
      "description": "Limit the player's view to the left\nSee also: SetViewExtentRight, GetCamera, SetViewExtentsByName"
   },
   "SetViewExtentRight": {
      "documentation": [
         "void SetViewExtentRight(float x)",
         "SetViewExtentRight(x)"
      ],
      "description": "Limit the player's view to the right\nSee also: SetViewExtentLeft, GetCamera, SetViewExtentsByName"
   },
   "SetViewExtentsByName": {
      "documentation": [
         "void SetViewExtentsByName(const char* name)",
         "SetViewExtentsByName(name)"
      ],
      "description": "Limits the player's view using a named screen\nOnly applied if local player is not an observer\nSee also: GetCamera, SetViewExtentsByNameRaw"
   },
   "SetViewExtentsByNameRaw": {
      "documentation": [
         "void SetViewExtentsByNameRaw(const char* name)",
         "SetViewExtentsByNameRaw(name)"
      ],
      "description": "Limits the player's view using a named screen\nSee also: GetCamera, SetViewExtentsByName"
   },
   "WorldToScreen": {
      "documentation": [
         "Vector3D WorldToScreen(const Vector3D& pos)",
         "local result = WorldToScreen(pos)"
      ],
      "description": "Transform a world position to screen coordinates\nUseful for attaching screen space controls to world locations"
   },
   "GetWaterDepthAt": {
      "documentation": [
         "float GetWaterDepthAt(const Vector3D& pos)",
         "local depth = GetWaterDepthAt(pos)"
      ],
      "description": "Query the depth of the water at specific point\nreturns: the distance below the surface pos is\nSee also: GetWaterLevel, GetStructureInWater"
   },
   "GetWaterLevel": {
      "documentation": [
         "float GetWaterLevel(float x)",
         "local result = GetWaterLevel(x)"
      ],
      "description": "Query the vertical coordinate of the world water level\nx: The horizontal position to query \nSee also: GetWaterDepthAt"
   },
   "OnStreamComplete": {
      "documentation": [
         "void OnStreamComplete(int seriesId, bool fromReplay)",
         "function OnStreamComplete(seriesId, fromReplay)\nend"
      ],
      "description": "Called when a stream started from StartStream is finished\nseriesId: return value of StartStream \nfromReplay: true if this is reproduced from a replay "
   },
   "OnDeviceCompleted": {
      "documentation": [
         "void OnDeviceCompleted(int teamId, int deviceId, const char* saveName)",
         "function OnDeviceCompleted(teamId, deviceId, saveName)\nend"
      ],
      "description": "Called when a device finishes construction\nteamId: the team the device belongs to \ndeviceId: the id of the device \nsaveName: the type of the device \nSee also: OnDeviceCreated, OnGroundDeviceCreated, OnDeviceDeleted, OnDeviceDestroyed, OnDeviceMoved"
   },
   "OnDeviceConsumed": {
      "documentation": [
         "void OnDeviceConsumed(int teamId, int deviceId, const char* saveName, int nodeA, int nodeB, float t)",
         "function OnDeviceConsumed(teamId, deviceId, saveName, nodeA, nodeB, t)\nend"
      ],
      "description": "Called when a device has been consumed by firing as ammo\nteamId: the teamId of the device \ndeviceId: the id of the device \nsaveName: the SaveName of the device \nnodeA: the first platform node of the device \nnodeB: the second platform node of the device \nt: the position of the device on the platform "
   },
   "OnDeviceCreated": {
      "documentation": [
         "void OnDeviceCreated(int teamId, int deviceId, const char* saveName, int nodeA, int nodeB, float t, int upgradedId)",
         "function OnDeviceCreated(teamId, deviceId, saveName, nodeA, nodeB, t, upgradedId)\nend"
      ],
      "description": "Called when a new platform device is created by a player or AI\nteamId: the team the device belongs to \ndeviceId: the id of the device \nsaveName: the identifying name of the device's type \nnodeA: the id of the first node of the platform link \nnodeB: the id of the second node of the platform link \nt: the position on the link the device was made [0-1] \nupgradeId: the id of a device that was upgraded to create this (0 if none) \nSee also: OnGroundDeviceCreated, CreateDevice, OnDeviceDestroyed"
   },
   "OnDeviceDeleted": {
      "documentation": [
         "void OnDeviceDeleted(int teamId, int deviceId, const char* saveName, int nodeA, int nodeB, float t)",
         "function OnDeviceDeleted(teamId, deviceId, saveName, nodeA, nodeB, t)\nend"
      ],
      "description": "Called when a device is deleted by a player or AI\nteamId: the team the device belongs to \ndeviceId: the id of the device \nsaveName: the identifying name of the device's type \nnodeA: the id of the first node of the platform link (-1 for ground devices) \nnodeB: the id of the second node of the platform link (-1 for ground devices) \nt: the position on the link the device was made [0-1] (0 for ground devices) \nSee also: DestroyDevice, OnDeviceDestroyed, OnDeviceCreated, OnGroundDeviceCreated"
   },
   "OnDeviceDestroyed": {
      "documentation": [
         "void OnDeviceDestroyed(int teamId, int deviceId, const char* saveName, int nodeA, int nodeB, float t)",
         "function OnDeviceDestroyed(teamId, deviceId, saveName, nodeA, nodeB, t)\nend"
      ],
      "description": "Called when a device is destroyed\nteamId: the team the device belongs to \ndeviceId: the id of the device \nsaveName: the identifying name of the device's type \nnodeA: the id of the first node of the platform link (-1 for ground devices) \nnodeB: the id of the second node of the platform link (-1 for ground devices) \nt: the position on the link the device was made [0-1] (0 for ground devices) \nSee also: OnDeviceDeleted, OnDeviceCreated, OnGroundDeviceCreated"
   },
   "OnDeviceHit": {
      "documentation": [
         "void OnDeviceHit(int teamId, int deviceId, const char* saveName, float newHealth, int projectileNodeId, int projectileTeamId, const Vector3D& pos, bool reflectedByEnemy)",
         "function OnDeviceHit(teamId, deviceId, saveName, newHealth, projectileNodeId, projectileTeamId, pos, reflectedByEnemy)\nend"
      ],
      "description": "Called when a device is impacted by a projectile (but not beams)\nteamId: the team the device belongs to \ndeviceId: the id of the device \nsaveName: the type of the device \nnewHealth: the current health of the device [0-1] \nprojectileNodeId: the id of the projectile which hit the device \nprojectileTeamId: the team of the projectile which hit the device \npos: the location of the impact \nSee also: OnDeviceDestroyed, OnProjectileDestroyed, OnLinkHit, OnTerrainHit"
   },
   "OnDeviceHitBeam": {
      "documentation": [
         "void OnDeviceHitBeam(int teamId, int deviceId, const char* saveName, float newHealth, int weaponId, const char* projectileSaveName, const Vector3D& pos)",
         "function OnDeviceHitBeam(teamId, deviceId, saveName, newHealth, weaponId, projectileSaveName, pos)\nend"
      ],
      "description": "Called when a device is impacted by a projectile (but not beams)\nteamId: the team the device belongs to \ndeviceId: the id of the device \nsaveName: the type of the device \nnewHealth: the current health of the device [0-1] \nweaponId: the id of the projectile which hit the device \nprojectileSaveName: the projectile type of the beam \npos: the location of the impact \nSee also: OnDeviceHit, OnLinkHitBeam, OnTerrainHitBeam"
   },
   "OnDeviceMoved": {
      "documentation": [
         "void OnDeviceMoved(int teamId, int deviceId, int temporaryDeviceId, const char* saveName)",
         "function OnDeviceMoved(teamId, deviceId, temporaryDeviceId, saveName)\nend"
      ],
      "description": "Called when a device finishes moving\nteamId: the team the device belongs to \ndeviceId: the id of the device \ntemporaryDeviceId: the id of the temporary device while moving \nsaveName: the type of the device \nSee also: OnDeviceCreated, OnDeviceCreated, OnDeviceDeleted, OnDeviceDestroyed, OnDeviceCompleted"
   },
   "OnDeviceSelected": {
      "documentation": [
         "void OnDeviceSelected(const char* saveName)",
         "function OnDeviceSelected(saveName)\nend"
      ],
      "description": "Called when the local player selects a device type on the HUD\nsaveName: the device type selected \nSee also: OnDeviceCreated, OnGroundDeviceCreated"
   },
   "OnDeviceTeamUpdated": {
      "documentation": [
         "void OnDeviceTeamUpdated(int oldTeamId, int newTeamId, int deviceId, const char* saveName)",
         "function OnDeviceTeamUpdated(oldTeamId, newTeamId, deviceId, saveName)\nend"
      ],
      "description": "Called when a device has changed teams, possibly to neutral\noldTeamId: the previous team of the device \nnewTeamId: the current team of the device \ndeviceId: the id of the device \nsaveName: the SaveName of the device "
   },
   "OnGroundDeviceCreated": {
      "documentation": [
         "void OnGroundDeviceCreated(int teamId, int deviceId, const char* saveName, const Vector3D& pos, int upgradedId)",
         "function OnGroundDeviceCreated(teamId, deviceId, saveName, pos, upgradedId)\nend"
      ],
      "description": "Called when a new ground device is created by a player or AI\nteamId: the team the device belongs to \ndeviceId: the id of the device \nsaveName: the identifying name of the device's type \npos: the position of the device \nupgradeId: the id of a device that was upgraded to create this (0 if none) \nSee also: OnDeviceCreated, CreateGroundDevice, OnDeviceDestroyed"
   },
   "OnWeaponFireAttemptFail": {
      "documentation": [
         "void OnWeaponFireAttemptFail(const char* saveName, int weaponId, int reasonCode)",
         "function OnWeaponFireAttemptFail(saveName, weaponId, reasonCode)\nend"
      ],
      "description": "Called when the local player tries to fire a weapon, but fails"
   },
   "OnWeaponFired": {
      "documentation": [
         "void OnWeaponFired(int teamId, const char* saveName, int weaponId, int projectileNodeId, int projectileNodeIdFrom)",
         "function OnWeaponFired(teamId, saveName, weaponId, projectileNodeId, projectileNodeIdFrom)\nend"
      ],
      "description": "A weapon has spawned a projectile\nalso called when secondary projectiles are made from projectile effects\nteamId: the owner of the weapon \nsaveName: the type of the weapon \nweaponId: the id of the weapon \nprojectileNodeId: the id of the spawned projectile \nprojectileNodeIdFrom: the parent projectile for secondary projectile spawn (0 if spawned by weapon) \nSee also: OnWeaponFiredEnd, OnProjectileCollision, OnProjectileDestroyed"
   },
   "OnWeaponFiredEnd": {
      "documentation": [
         "void OnWeaponFiredEnd(int teamId, const char* saveName, int weaponId)",
         "function OnWeaponFiredEnd(teamId, saveName, weaponId)\nend"
      ],
      "description": "Called when a weapon has stopped firing (e.g. end of burst, end of beam)\nteamId: the owner of the weapon \nsaveName: the type of the weapon \nweaponId: the id of the weapon \nSee also: OnWeaponFired"
   },
   "OnWeaponOverheated": {
      "documentation": [
         "void OnWeaponOverheated(int teamId, const char* saveName, int weaponId)",
         "function OnWeaponOverheated(teamId, saveName, weaponId)\nend"
      ],
      "description": "Called when a weapon overheats\nteamId: the owner of the weapon \nsaveName: the type of the weapon \nweaponId: the id of the weapon \nSee also: OnWeaponFired, OnWeaponFiredEnd"
   },
   "OnBuildError": {
      "documentation": [
         "void OnBuildError(int teamId, int type)",
         "function OnBuildError(teamId, type)\nend"
      ],
      "description": "Called when the player makes a mistake during building\nteamId: the teamId of the player \ntype: one of the BUILDERROR_* values defined in forts.lua "
   },
   "OnContextButtonDevice": {
      "documentation": [
         "void OnContextButtonDevice(const string& script, const char* name, int deviceTeamId, int deviceId, const char* saveName)",
         "function OnContextButtonDevice(script, name, deviceTeamId, deviceId, saveName)\nend"
      ],
      "description": "Called when the player clicks on a device context button added via AddContextButton\nSee also: AddContextButton, OnContextMenuDevice"
   },
   "OnContextButtonStrut": {
      "documentation": [
         "void OnContextButtonStrut(const string& script, const char* name, int teamId, int nodeA, int nodeB, const char* saveName)",
         "function OnContextButtonStrut(script, name, teamId, nodeA, nodeB, saveName)\nend"
      ],
      "description": "Called when the player clicks on a strut context button added via AddContextButton\nSee also: AddContextButton, OnContextMenuStrut"
   },
   "OnContextMenuDevice": {
      "documentation": [
         "void OnContextMenuDevice(int deviceTeamId, int deviceId, const char* saveName)",
         "function OnContextMenuDevice(deviceTeamId, deviceId, saveName)\nend"
      ],
      "description": "Called when the player opens the context menu on a device\nUsed for customising the context menu\nSee also: AddContextButton, OnContextMenuDevice"
   },
   "OnContextMenuStrut": {
      "documentation": [
         "void OnContextMenuStrut(int strutTeamId, int nodeA, int nodeB, const char* saveName)",
         "function OnContextMenuStrut(strutTeamId, nodeA, nodeB, saveName)\nend"
      ],
      "description": "Called when the player opens the context menu on a strut\nUsed for customising the context menu\nSee also: AddContextButton, OnContextButtonStrut"
   },
   "OnDeviceCreateDisrupted": {
      "documentation": [
         "void OnDeviceCreateDisrupted(int teamId, const char* saveName, const Vector3D& pos)",
         "function OnDeviceCreateDisrupted(teamId, saveName, pos)\nend"
      ],
      "description": "Called when a player or AI attempts to build a device in a disruption field\nteamId: the team of the disrupted player or AI \nsaveName: the type of the device attempted to build \npos: the attempted location for the construction \nSee also: OnTargetDisrupted, OnStructureCreateDisrupted"
   },
   "OnGroupAddition": {
      "documentation": [
         "void OnGroupAddition(int index, int masterDeviceId, int slaveDeviceId)",
         "function OnGroupAddition(index, masterDeviceId, slaveDeviceId)\nend"
      ],
      "description": "Called when the local player adds a device to a group\nthe group may already have other slaves\nindex: the group identifier \nmasterDeviceId: the controlling weapon \nslaveDeviceId: the added device \nSee also: OnGroupFired"
   },
   "OnGroupFired": {
      "documentation": [
         "void OnGroupFired(int index, int masterDeviceId, bool cycle, int fired, int count)",
         "function OnGroupFired(index, masterDeviceId, cycle, fired, count)\nend"
      ],
      "description": "Called when the player fires a weapon group\nindex: the group number (-1 for a group unassigned to a number) \nmasterDeviceId: the device id of the leader of the group \ncycle: set to true when using round robin firing \nfired: the number of weapons actually fired \ncount: the number of weapons in the group "
   },
   "OnGroupMemberDeselected": {
      "documentation": [
         "void OnGroupMemberDeselected(int deviceId)",
         "function OnGroupMemberDeselected(deviceId)\nend"
      ],
      "description": "Called when the local player selects a single device or a group"
   },
   "OnGroupMemberSelected": {
      "documentation": [
         "void OnGroupMemberSelected(int deviceId)",
         "function OnGroupMemberSelected(deviceId)\nend"
      ],
      "description": "Called when the local player selects a single device or a group"
   },
   "OnStructureCreateDisrupted": {
      "documentation": [
         "void OnStructureCreateDisrupted(int teamId, const Vector3D& pos)",
         "function OnStructureCreateDisrupted(teamId, pos)\nend"
      ],
      "description": "Called when a player or AI attempts to build structure in a disruption field\nteamId: the team of the disrupted player or AI \npos: the attempted location for the construction \nSee also: OnTargetDisrupted, OnDeviceCreateDisrupted"
   },
   "OnTabOpened": {
      "documentation": [
         "void OnTabOpened(const char* name)",
         "function OnTabOpened(name)\nend"
      ],
      "description": "Called when a different tab is selected\nname: can be \"materials\", \"devices\", \"tech\", \"weapons\", \"terrain\", \"surfaces\", or \"props\" "
   },
   "OnKey": {
      "documentation": [
         "bool OnKey(const char* key, bool down)",
         "function OnKey(key, down)\nend"
      ],
      "description": "The player has pressed a key or mouse button"
   },
   "OnExecuteProjectileAction": {
      "documentation": [
         "void OnExecuteProjectileAction(int nodeId, const char* saveName, const Vector3D& pos, const Vector3D& normal, HitType hitType, int hitTeamId, const char* hitSaveName)",
         "function OnExecuteProjectileAction(nodeId, saveName, pos, normal, hitType, hitTeamId, hitSaveName)\nend"
      ],
      "description": "Called when two projectiles collide in mid-air\nnodeId: the id of the projectile \nsaveName: the type of the projectile \npos: the position of the impact \nnormal: the surface normal of the impact \nhitType: the impact or expiry type \nhitTeamId: the team of the impacting object \nhitSaveName: the savename of the impacting object \nSee also: OnProjectileCollision"
   },
   "OnLinkHit": {
      "documentation": [
         "void OnLinkHit(int nodeIdA, int nodeIdB, int objectId, int objectTeamId, const char* objectSaveName, float damage, const Vector3D& pos, bool reflectedByEnemy)",
         "function OnLinkHit(nodeIdA, nodeIdB, objectId, objectTeamId, objectSaveName, damage, pos, reflectedByEnemy)\nend"
      ],
      "description": "Called when a projectile impacts a strut (not beams or splash damage)\nnodeIdA: the first node id of the strut \nnodeIdB: the second node id of the strut \nobjectId: the projectile id \nobjectTeamId: the owning team of projectile \nobjectSaveName: the type of the projectile \nSee also: OnPortalUsed, OnShieldReflection, OnLinkDestroyed, OnDeviceHit, OnTerrainHit"
   },
   "OnLinkHitBeam": {
      "documentation": [
         "void OnLinkHitBeam(int nodeIdA, int nodeIdB, int weaponId, int weaponTeamId, const char* projectileSaveName, float damage, const Vector3D& pos)",
         "function OnLinkHitBeam(nodeIdA, nodeIdB, weaponId, weaponTeamId, projectileSaveName, damage, pos)\nend"
      ],
      "description": "Called when a beame impacts a strut\nnodeIdA: the first node id of the strut \nnodeIdB: the second node id of the strut \nweaponId: the weapon id \nweaponTeamId: the owning team of projectile \nprojectileSaveName: the projectile type of the beam \nSee also: OnLinkHit, OnDeviceHitBeam, OnTerrainHitBeam"
   },
   "OnPortalUsed": {
      "documentation": [
         "void OnPortalUsed(int nodeA, int nodeB, int nodeADest, int nodeBDest, int objectTeamId, int objectId, bool isBeam)",
         "function OnPortalUsed(nodeA, nodeB, nodeADest, nodeBDest, objectTeamId, objectId, isBeam)\nend"
      ],
      "description": "Called when a projectile or beam passes through a portal\nnodeA: the first node id of the source portal \nnodeB: the second node id of the source portal \nnodeADest: the first node id of the destination portal \nnodeBDest: the second node id of the destination portal \nobjectTeamId: the owning team of projectile or beam \nobjectId: the projectile id, or the weapon's id if beam \nisBeam: true when a beam has been passed, otherwise a projectile \nSee also: OnShieldReflection"
   },
   "OnProjectileCollision": {
      "documentation": [
         "void OnProjectileCollision(int teamIdA, int nodeIdA, const char* saveNameA, int teamIdB, int nodeIdB, const char* saveNameB)",
         "function OnProjectileCollision(teamIdA, nodeIdA, saveNameA, teamIdB, nodeIdB, saveNameB)\nend"
      ],
      "description": "Called when two projectiles collide in mid-air\nNot called for projectile-beam collisions\nteamIdA: the team of the first projectile \nnodeIdA: the id of the first projectile \nsaveNameA: the type of the first projectile \nteamIdB: the team of the second projectile \nnodeIdB: the id of the second projectile \nsaveNameB: the type of the second projectile \nSee also: OnWeaponFired, OnProjectileDestroyed"
   },
   "OnProjectileDestroyed": {
      "documentation": [
         "void OnProjectileDestroyed(int nodeId, int teamId, const char* saveName, int structureIdHit, int destroyType)",
         "function OnProjectileDestroyed(nodeId, teamId, saveName, structureIdHit, destroyType)\nend"
      ],
      "description": "Called when a projectile node is destroyed\nThe node exists at the time of the call, and is removed immediately after\nnodeId: the id of the projectile node \nteamId: the owner of the projectile (can be None) \nsaveName: the type of the projectile \nstructureIdHit: the id of the last structure hit \ndestroyType: one of the DESTROYTYPE_* values defined in forts.lua \nSee also: OnNodeDestroyed, OnProjectileRedirected"
   },
   "OnProjectileRedirected": {
      "documentation": [
         "void OnProjectileRedirected(int nodeId, int teamId, int decoyTeamId, const char* saveName, int decoyNodeId)",
         "function OnProjectileRedirected(nodeId, teamId, decoyTeamId, saveName, decoyNodeId)\nend"
      ],
      "description": "Called when a mesh projectile is redirected by a decoy\nnodeId: the id of the projectile node \nteamId: the owner of the projectile (can be None) \ndecoyTeamId: the owner of the decoy (can be None) \nsaveName: the type of the projectile \ndecoyNodeId: the id of the decoy causing the redirect \nSee also: OnProjectileDestroyed"
   },
   "OnShieldReflection": {
      "documentation": [
         "void OnShieldReflection(int nodeA, int nodeB, int objectTeamId, int objectId, bool isBeam)",
         "function OnShieldReflection(nodeA, nodeB, objectTeamId, objectId, isBeam)\nend"
      ],
      "description": "Called when a projectile or beam is reflected off a strut\nnodeA: the first node id of the strut \nnodeB: the second node id of the strut \nobjectTeamId: the owning team of projectile or beam \nobjectId: the projectile id, or the weapon's id if beam \nisBeam: true when a beam has been passed, otherwise a projectile \nSee also: OnPortalUsed"
   },
   "OnTargetDisrupted": {
      "documentation": [
         "void OnTargetDisrupted(int teamId, int deviceId)",
         "function OnTargetDisrupted(teamId, deviceId)\nend"
      ],
      "description": "Called when a spotter for a missile type weapon aims into a disruption field (e.g. smoke)\nteamId: the owner of the spotting device \ndeviceId: the id of the spotting device \nSee also: OnStructureCreateDisrupted, OnDeviceCreateDisrupted"
   },
   "OnTerrainHit": {
      "documentation": [
         "void OnTerrainHit(int terrainId, float damage, int projectileNodeId, const char* projectileSaveName, int surfaceType, const Vector3D& pos, const Vector3D& normal, bool reflectedByEnemy)",
         "function OnTerrainHit(terrainId, damage, projectileNodeId, projectileSaveName, surfaceType, pos, normal, reflectedByEnemy)\nend"
      ],
      "description": "Called when a projectile collides with a terrain block\nterrainId: the id of the terrain block hit \ndamage: the raw damage carried by the projectile (may be reduced by other collisions) \nprojectileNodeId: the id of the projectile which hit the terrain \nprojectileSaveName: the type of the projectile \nsurfaceType: the surface type index hit \npos: the position of the impact \nnormal: the surface normal of the impact \nSee also: OnTerrainHitBeam, OnProjectileDestroyed, OnLinkHit, OnDeviceHit, GetSurfaceSaveName"
   },
   "OnTerrainHitBeam": {
      "documentation": [
         "void OnTerrainHitBeam(int terrainId, float damage, int weaponId, const char* projectileSaveName, int surfaceType, const Vector3D& pos, const Vector3D& normal)",
         "function OnTerrainHitBeam(terrainId, damage, weaponId, projectileSaveName, surfaceType, pos, normal)\nend"
      ],
      "description": "Called when a beam collides with a terrain block\nterrainId: the id of the terrain block hit \ndamage: the damage carried by the beam \nweaponId: the weapon that fired the beam \nprojectileSaveName: the projectile type of the beam \nsurfaceType: the surface type index hit \npos: the position of the impact \nnormal: the surface normal of the impact \nSee also: OnTerrainHit, OnWeaponFired, GetSurfaceSaveName, OnLinkHitBeam, OnDeviceHitBeam"
   },
   "OnAchievement": {
      "documentation": [
         "void OnAchievement(int index)",
         "function OnAchievement(index)\nend"
      ],
      "description": "Called when the player achieves a mission objective\nindex: the index of the objective (0, 1, or 2) "
   },
   "OnGameResult": {
      "documentation": [
         "void OnGameResult(int winningTeamId, bool customCondition)",
         "function OnGameResult(winningTeamId, customCondition)\nend"
      ],
      "description": "Called when the battle has been won\nwinningTeamId: the id of the winning team (1 or 2) \ncustomCondition: true when the won via a custom script condition "
   },
   "OnShowResult": {
      "documentation": [
         "void OnShowResult()",
         "function OnShowResult()\nend"
      ],
      "description": "Called when the victory/defeat banner is displayed\nThis happens some time after the result is actually decided\nSee also: OnGameResult"
   },
   "OnTeamDefeated": {
      "documentation": [
         "void OnTeamDefeated(int defeatedTeamId)",
         "function OnTeamDefeated(defeatedTeamId)\nend"
      ],
      "description": "Called when a team has lost its last reactor\ndefeatedTeamId: the id of the team that has been destroyed "
   },
   "OnDoorControl": {
      "documentation": [
         "void OnDoorControl(int teamId, int nodeA, int nodeB, bool opening)",
         "function OnDoorControl(teamId, nodeA, nodeB, opening)\nend"
      ],
      "description": "Called when a door is opened by a player (not AI)\nteamId: the owner of the door \nnodeA: the id of the first node of the door \nnodeB: the id of the second node of the door \nopening: true if the door is opening, otherwise it is closing "
   },
   "OnDoorState": {
      "documentation": [
         "void OnDoorState(int teamId, int nodeA, int nodeB, int doorState)",
         "function OnDoorState(teamId, nodeA, nodeB, doorState)\nend"
      ],
      "description": "Called when a door changes state\nteamId: the owner of the door \nnodeA: the id of the first node of the door \nnodeB: the id of the second node of the door \ndoorState: one of the DS_* values from forts.lua, e.g. DS_CLOSED, DS_OPENING "
   },
   "OnLinkCreated": {
      "documentation": [
         "void OnLinkCreated(int teamId, const char* saveName, int nodeA, int nodeB, const Vector3D& pos1, const Vector3D& pos2, bool extrusion)",
         "function OnLinkCreated(teamId, saveName, nodeA, nodeB, pos1, pos2, extrusion)\nend"
      ],
      "description": "Called when a new strut is created by a player or AI\nteamId: the team the strut belongs to \nsaveName: the identifying name of the link's material \nnodeA: the id of the first node of the link \nnodeB: the id of the second node of the link \npos1: the position of the first node of the link \npos2: the position of the second node of the link \nextrusion: true if the link was created as part of an extrusion \nSee also: CreateLink, OnLinkDestroyed, OnNodeCreated"
   },
   "OnLinkDestroyed": {
      "documentation": [
         "void OnLinkDestroyed(int teamId, const char* saveName, int nodeA, int nodeB, int breakType)",
         "function OnLinkDestroyed(teamId, saveName, nodeA, nodeB, breakType)\nend"
      ],
      "description": "Called when a strut is destroyed or deleted\nThis is called for every segment of a rope\nThe link exists at the time of the call, and is removed immediately after\nteamId: the owning team of the strut \nsaveName: the material type of the strut \nnodeA: the first node id of the strut \nnodeB: the second node id of the strut \nbreakType: one of the LINKBREAK_* values from forts.lua, e.g. LINKBREAK_PROJECTILE, LINKBREAK_DELETE \nSee also: OnLinkHit, OnLinkCreated, OnNodeDestroyed"
   },
   "OnMaterialSelected": {
      "documentation": [
         "void OnMaterialSelected(const char* saveName)",
         "function OnMaterialSelected(saveName)\nend"
      ],
      "description": "So different scripts can enforce minimum delays between tips\nsaveName: the material type selected \nSee also: OnLinkCreated"
   },
   "OnNodeBroken": {
      "documentation": [
         "void OnNodeBroken(int nodeId, int nodeIdNew)",
         "function OnNodeBroken(nodeId, nodeIdNew)\nend"
      ],
      "description": "Called when a node is broken in two due to link rotation\nnodeId: the original node - this will still exist \nnodeIdNew: the node created during the break, which will accept one or more of the links of the old node "
   },
   "OnNodeCreated": {
      "documentation": [
         "void OnNodeCreated(int nodeId, int teamId, const Vector3D& pos, bool foundation, bool selectable, bool extrusion)",
         "function OnNodeCreated(nodeId, teamId, pos, foundation, selectable, extrusion)\nend"
      ],
      "description": "Called when a new joint is created by a player or AI\nDoes not include when an existing joint breaks or when projectiles are created\nnodeId: the id of the node \nteamId: the team the node belongs to \npos: where the node is currently located \nfoundation: true if the node is a foundation \nselectable: true if the node can be selected (intermediate nodes of ropes can't be selected) \nextrusion: true if the node was created as part of an extrusion \nSee also: CreateNode, OnLinkCreated, OnNodeDestroyed, OnWeaponFired"
   },
   "OnNodeDestroyed": {
      "documentation": [
         "void OnNodeDestroyed(int nodeId, bool selectable)",
         "function OnNodeDestroyed(nodeId, selectable)\nend"
      ],
      "description": "Called when a structure node is destroyed\nDoes not include projectiles, see OnProjectileDestroyed instead\nThe node exists at the time of the call, and is removed immediately after\nnodeId: the id of the node \nselectable: true if the node could be selected (intermediate rope nodes are not selectable) \nSee also: OnProjectileDestroyed, OnLinkDestroyed"
   },
   "OnRepairArea": {
      "documentation": [
         "void OnRepairArea(int teamId, const Vector3D& pos, int links, int fireSegments, int devices)",
         "function OnRepairArea(teamId, pos, links, fireSegments, devices)\nend"
      ],
      "description": "Called when a player repairs an area\nteamId: the team of the player \npos: the centre of the area \nlinks: the number of struts that are now repairing in the area \nfireSegments: the number of fire segments in the area being extinguished \ndevices: the number of devices now repairing in the area \nSee also: RepairLink, RepairDevice"
   },
   "OnStructurePainted": {
      "documentation": [
         "void OnStructurePainted(int teamId, int structureId, int firstNodeId)",
         "function OnStructurePainted(teamId, structureId, firstNodeId)\nend"
      ],
      "description": "Called when a new structure is identified\nEach separate structure is assigned its own unique id\nOnly enabled during LoadStructureFile with structurePaintedCallback set to true\nteamId: the owner of the structure \nstructureId: the assigned id of the structure \nfirstNodeId: the id with the lowest id in the structure \nSee also: LoadStructureFile"
   },
   "Cleanup": {
      "documentation": [
         "void Cleanup()",
         "function Cleanup()\nend"
      ],
      "description": "Called when restarting and returning to the menu"
   },
   "Load": {
      "documentation": [
         "void Load(bool gameStart)",
         "function Load(gameStart)\nend"
      ],
      "description": "Called at the start of a battle"
   },
   "OnExit": {
      "documentation": [
         "void OnExit()",
         "function OnExit()\nend"
      ],
      "description": "Called when the player exits a battle"
   },
   "OnInstantReplay": {
      "documentation": [
         "void OnInstantReplay()",
         "function OnInstantReplay()\nend"
      ],
      "description": "Called when instant replay is started"
   },
   "OnNext": {
      "documentation": [
         "void OnNext()",
         "function OnNext()\nend"
      ],
      "description": "Called when the player clicks the 'next' pause menu option during a campaign"
   },
   "OnPreRestart": {
      "documentation": [
         "void OnPreRestart()",
         "function OnPreRestart()\nend"
      ],
      "description": "Called before the battle is restarted"
   },
   "OnPreSeek": {
      "documentation": [
         "void OnPreSeek()",
         "function OnPreSeek()\nend"
      ],
      "description": "Called during replays before a seek"
   },
   "OnRestart": {
      "documentation": [
         "void OnRestart()",
         "function OnRestart()\nend"
      ],
      "description": "Called when the battle is restarted"
   },
   "OnSeek": {
      "documentation": [
         "void OnSeek()",
         "function OnSeek()\nend"
      ],
      "description": "Called during replays after a seek"
   },
   "OnSeekStart": {
      "documentation": [
         "void OnSeekStart()",
         "function OnSeekStart()\nend"
      ],
      "description": "Called during replays when seeking to start"
   },
   "OnUpdate": {
      "documentation": [
         "void OnUpdate(float timeDelta)",
         "function OnUpdate(timeDelta)\nend"
      ],
      "description": "Called every display frame (not physics frame). Use this for updating debugging, visuals or audio only."
   },
   "Update": {
      "documentation": [
         "void Update(int frame)",
         "function Update(frame)\nend"
      ],
      "description": "The main entry point for arbitrary game state tracking and changes. Called for every physics frame.\nYou can use OnUpdate for visual/audio changes instead for more frequent execution.\nSee also: OnUpdate"
   },
   "OnEnableTip": {
      "documentation": [
         "void OnEnableTip(const char* name, bool enable)",
         "function OnEnableTip(name, enable)\nend"
      ],
      "description": "Called when a tip is enabled or disabled\nSee also: EnableTip"
   },
   "OnTipHidden": {
      "documentation": [
         "void OnTipHidden(const char* stringId, bool dismissed)",
         "function OnTipHidden(stringId, dismissed)\nend"
      ],
      "description": "Called when the player satisfies or dismisses a tip"
   },
   "DismissResult": {
      "documentation": [
         "bool DismissResult(LuaState* missionScript)",
         "function DismissResult(missionScript)\nend"
      ],
      "description": "Called by game when the player escapes (e.g. clicks on) the victory/defeat banner\nReturn true to bring up the post-game pause menu"
   },
   "OnControlActivated": {
      "documentation": [
         "void OnControlActivated(const char* name, int code, bool doubleClick)",
         "function OnControlActivated(name, code, doubleClick)\nend"
      ],
      "description": "Called when a user interface control is pressed by the player\nname: the name of the control \ncode: unused (will be nil) \ndoubleClick: true when the user has double clicked the control "
   }
}